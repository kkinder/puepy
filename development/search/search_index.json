{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PuePy: Overview","text":"<p>PuePy is a frontend web framework that builds on Python and Webassembly using PyScript. PuePy is truly a Python-first development environment. There is no transpiling to JavaScript; no Yarn, no NPM, no webpack, no Vite or Parcel. Python runs directly in your browser. PuePy is inspired by Vue.js, but is built entirely from scratch in Python.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Reactivity: As components' state changes, redraws happen automatically</li> <li>Component-Based Design: Encapsulate data, logic, and presentation in reusable components</li> <li>Single-Class Components: Based vaguely on Vue's \"single file components\", each component and each page is a class.</li> <li>Events, Slots, and Props: Events, slots, and props are all inspired by Vue and work similarly in PuePy</li> <li>Minimal, Python: PuePy is built to use Pythonic conventions whenever possible, and eschews verbosity in the name   of opinion.</li> </ul>"},{"location":"#external-links","title":"External Links","text":"<p>PuePy.dev Main Site GitHub</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#philosophical-questions","title":"Philosophical Questions","text":""},{"location":"faq/#why-not-just-use-javascript","title":"Why not just use Javascript?","text":"<p>If you prefer JavaScript to Python, using it would be the obvious answer. JavaScript has mature tooling available, there are many excellent frameworks to choose from, and the JavaScript runtimes available in most browsers are blazingly fast.</p> <p>Some developers prefer Python, however. For them, PuePy might be a good choice.</p>"},{"location":"faq/#is-webassembly-ready","title":"Is WebAssembly ready?","text":"<p>WebAssembly is supported in all major modern browsers, including Safari. Its standard has coalesced and for using existing JavaScript libraries or components, PyScript provides a robust bridge. WebAssembly is as ready as it needs to be and is certainly less prone to backwards incompatible changes than many JavaScript projects that production sites rely on.</p>"},{"location":"faq/#puepy-design-choices","title":"PuePy Design Choices","text":""},{"location":"faq/#can-you-use-puepy-with-a-templating-language-instead-of-building-components-inline","title":"Can you use PuePy with a templating language instead of building components inline?","text":"<p>The idea behind PuePy is, at least in part, to have the convenience of building all your software, including its UI, out in Python's syntax. You may actually find that Python is more succinct, not less, than a similar template might be. Consider:</p> <pre><code>&lt;h1&gt;{{ name }}'s grocery shopping list&lt;/h1&gt;\n&lt;ul&gt;\n\n&lt;/ul&gt;\n&lt;button on_click=\"buy()\"&gt;Buy Items&lt;/button&gt;\n</code></pre> <p>vs:</p> <pre><code>with t.h1():\n    t(f\"{name}'s grocery shopping list\")\nwith t.ul():\n    for item in items:\n       t.li(item)\nt.button(\"Buy Items\", on_click=self.buy)\n</code></pre> <p>If you have a whole HTML file ready to go, try out the HTML to Python converter built in the PypII libraries tutorial chapter, which uses BeautifulSoup.</p>"},{"location":"faq/#can-i-use-svgs","title":"Can I use SVGs?","text":"<p>Yes, as long as you specify xmlns:</p> <pre><code>with t.svg(xmlns=\"http://www.w3.org/2000/svg\"):\n    ...\n</code></pre>"},{"location":"faq/#how-can-i-use-html-directly","title":"How can I use HTML directly?","text":"<p>If you want to directly insert HTML into a component's rendering, you can use the <code>html()</code> string:</p> <pre><code>from puepy.core import html\n\n\nclass MyPage(Page):\n    def populate(self):\n        t(html(\"&lt;strong&gt;Hello!&lt;/strong&gt;\"))\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#client-side-installation","title":"Client-side installation","text":"<p>Although PuePy is available on pypi, because PuePy is intended primarily as a client-side framework, \"installation\" is best achieved by downloading the wheel file and including it in your pyscript <code>packages</code> configuration.</p> <p>A simple first project (with no web server) would be:</p> <ul> <li><code>index.html</code> (index.html file)</li> <li><code>pyscript.json</code> (pyscript config file)</li> <li><code>hello.py</code> (Hello World code)</li> <li><code>puepy-0.6.2-py3-none-any.whl</code> (PuePy wheel file)</li> </ul> <p>The runtime file would contain only the files needed to actually execute PuePy code; no tests or other files.  Runtime zips are available in each release's notes on GitHub.</p>"},{"location":"installation/#downloading-client-runtime","title":"Downloading client runtime","text":"<pre><code>curl -O https://download.puepy.dev/puepy-0.6.2-py3-none-any.whl\n</code></pre>"},{"location":"installation/#setting-up-your-first-project","title":"Setting up your first project","text":"<p>Continue to the tutorial to see how to set up your first project.</p>"},{"location":"cookbook/loading-indicators/","title":"Showing Loading Indicators","text":"<p>PyScript, on which PuePy is built, provides two runtime options. When combined with PuePy, the total transfer size to render a PuePy page as reported by Chromium's dev tools for each runtime are:</p> Runtime Transfer Size MicroPython 353 KB Pyodide 5.9 MB <p>MicroPython's runtime, even on a slower connection, is well within the bounds of normal web frameworks. Pyodide, however, will be perceived as initially quite slow to load on slower connections. Pyodide may be workable for internal line-of-business software where users have fast connections or in cases where it's accepted that an application may take some time to initially load, but will be cached during further use.</p>"},{"location":"cookbook/loading-indicators/#showing-an-indicator-before-puepy-loads","title":"Showing an indicator before PuePy loads","text":"<p>Before you mount your PuePy page into its target element, the target element's HTML is rendered in the browser. A very simple way to show that PuePy hasn't loaded is to include an indicator in the target element, which will be replaced upon execution by PuePy:</p> <pre><code>&lt;div id=\"app\"&gt;Loading...&lt;/div&gt;\n</code></pre> <p>The Full App Template example from the tutorial makes use of a Shoelace web component to show a visual loading indicator as a spinning wheel:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Example&lt;/title&gt;\n    &lt;link rel=\"stylesheet\" href=\"app.css\"&gt;\n\n    &lt;link rel=\"stylesheet\" href=\"https://pyscript.net/releases/2025.2.2/core.css\"&gt;\n    &lt;script type=\"module\" src=\"https://pyscript.net/releases/2025.2.2/core.js\"&gt;&lt;/script&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.1/cdn/themes/light.css\"/&gt;\n    &lt;script type=\"module\" src=\"https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.1/cdn/shoelace.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;!-- Show the application with a loading indicator that will be replaced later --&gt;\n&lt;div id=\"app\"&gt;\n    &lt;div style=\"text-align: center; height: 100vh; display: flex; justify-content: center; align-items: center;\"&gt;\n        &lt;sl-spinner style=\"font-size: 50px; --track-width: 10px;\"&gt;&lt;/sl-spinner&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n&lt;script type=\"mpy\" src=\"./main.py\" config=\"./pyscript-app.json\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>This will render as a loading indicator, animated, visible only until PuePy mounts the real application code:</p> <p></p>"},{"location":"cookbook/navigation-guards/","title":"Navigation Guards","text":"<p>When a page loads, you can guard navigation to that page by running a precheck  \u2013 a method that runs before the page is rendered. If the precheck raises an exception, the page is not rendered, and the exception is caught by the framework. This is useful for checking if a user is authenticated, for example.</p> <p>Here's an example of a precheck that raises an exception if the user is not authenticated:</p> Showing error<pre><code>from puepy import exceptions, Page\n\nclass MyPage(Page):\n    ...\n    def precheck(self):\n        if not self.application.state[\"authenticated_user\"]:\n            raise exceptions.Unauthorized()\n</code></pre> <p>In this example, if the <code>authenticated_user</code> key in the application state is <code>False</code>, the page will not render, and an <code>Unauthorized</code> exception will be raised. PuePy will then display your <code>application.unauthorized_page</code>.</p> <p>Alternatively, you could redirect the user by raising puepu.exceptions.Redirect:</p> Redirecting to a login page<pre><code>from puepy import exceptions, Page\n\n\nclass LoginPage(Page):\n    ...\n\n\nclass MyPage(Page):\n    ...\n    def precheck(self):\n        if not self.application.state[\"authenticated_user\"]:\n            raise exceptions.Redirect(LoginPage)\n</code></pre>"},{"location":"guide/advanced-routing/","title":"Router","text":"<p>Client-side routing in PuePy is optional. If enabled, the router allows you to define multiple \"pages\" with their own URLs.</p> <p>See Also</p> <ul> <li>Tutorial: Routing</li> <li>Reference: puepy.router</li> </ul> <p>If you do not install the router, you can only define one page, and that page will be mounted on the target element. If you install the router, the browser's URL will determine which page is mounted, based on the link mode used.</p>"},{"location":"guide/advanced-routing/#installing-the-router","title":"Installing the router","text":"<p>Routing is an entirely optional feature of PuePy. Many projects may prefer to rely on backend-side routing, like a traditional web project. However if you are developing a single-page app, or simply want to use multiple \"subpages\" on the page you made using PuePy, you must install the router by calling <code>app.install_router</code>.</p> <pre><code>from puepy import Application\nfrom puepy.router import Router\n\n\napp = Application()\napp.install_router(Router, link_mode=Router.LINK_MODE_HASH)\n</code></pre> <p><code>link_mode</code> defines how PuePy both creates and parses URLs. There are three options:</p> link_mode description pro/con <code>Router.LINK_MODE_HASH</code> Uses window location \"anchor\" (the part of the URL after a #) to determine route Simple implementation, works with any backend <code>Router.LINK_MODE_HTML5</code> Uses browser's history API to manipulate page URLs without causing a reload Cleaner URLs (but requires backend configuration) <code>Router.LINK_MODE_DIRECT</code> Keeps routing information on the client, but links directly to pages, causing reload Might be ideal for niche use cases or server-side rendering <p>Tip</p> <p>If you want to use client-side routing but aren't sure what <code>link_mode</code> to enable, \"hash\" is probably your best bet.</p>"},{"location":"guide/advanced-routing/#accessing-the-router-object","title":"Accessing the Router object","text":"<p>Once enabled, the Router object may be accessed on any component using <code>self.page.router</code>.</p>"},{"location":"guide/advanced-routing/#defining-routes","title":"Defining routes","text":"<p>The preferred way of adding pages to the router is by calling the <code>@app.page</code> decorator on your Application object  (see Hello World in the tutorial.</p> <pre><code>from puepy import Page\n\n\n@app.page(\"/my-page\")\nclass MyPage(Page):\n    ...\n</code></pre> <p>Or, define a default route by not passing a path.</p> <pre><code>@app.page()\nclass MyPage(Page):\n    ...\n</code></pre> <p>You can also add routes directly, though this isn't the preferred method.</p> <pre><code>app.router.add_route(path_match=\"/foobar\", page_class=Foobar)\n</code></pre>"},{"location":"guide/advanced-routing/#route-names","title":"Route names","text":"<p>By default, routes are named by converting the class name to lower case, and replacing <code>MixedCase</code> with <code>under_scores</code>. For instance, <code>MyPage</code> would be converted to <code>my_page</code> as a route name. You may, however, give your routes custom names by passing a <code>name</code> parameter to either <code>add_route</code> or <code>@app.page</code>:</p> <pre><code>@app.page(\"/my-page\", name=\"another_name\")\nclass MyPage(Page):\n    ...\n\n\nclass AnotherPage(Page):\n    ...\n\n\napp.add_route(\"/foobar\", AnotherPage, name=\"foobar\")\n</code></pre>"},{"location":"guide/advanced-routing/#passing-parameters-to-pages","title":"Passing parameters to pages","text":"<p>Pages can accept parameters fropm the router with props matching placeholders defined in the route path.</p> <pre><code>@app.page(\"/post/&lt;author_id&gt;/&lt;post_id&gt;/view\")\nclass PostPage(Page):\n    props = [\"author_id\", \"post_id\"]\n\n    def populate(self):\n        t.p(f\"This is a post from {self.author_id}-&gt;{self.user_id}\")\n</code></pre>"},{"location":"guide/advanced-routing/#reversing-routes","title":"Reversing routes","text":"<p>Call <code>router.reverse</code> with the page you want to find the route for, along with any relevant arguments.</p> <pre><code>path = self.page.router.reverse(PostPage, author_id=\"5\", post_id=\"7\")\n</code></pre> <p>The page can either be the Page object itself, or the route name.</p> <pre><code>path = self.page.router.reverse(\"post_page\", author_id=\"5\", post_id=\"7\")\n</code></pre>"},{"location":"guide/css-classes/","title":"CSS Classes","text":"<p>Although you are in charge of your own CSS, PuePy provides some convenience mechanisms for defining CSS classes. Because <code>class</code> is a reserved word in Python, when passing classes to tags, you should use either <code>class_name</code> or <code>classes</code>. Each can be defined as a string, list, or dictionary:</p> <pre><code>@app.page()\nclass HelloWorldPage(Page):\n    def populate(self):\n        t.button(\"Primary Large Button\", class_name=\"primary large\")\n        t.button(\"Primary Small Button\", classes=[\"primary\", \"small\"])\n        t.button(\"Primary Medium Button\", classes={\n            \"primary\": True, \n            \"medium\": True, \n            \"small\": False, \n            \"large\": False})\n</code></pre> <p>Notice that when passing a dictionary, the value of the dictionary indicates whether the class will be included.</p>"},{"location":"guide/css-classes/#components-and-classes","title":"Components and classes","text":"<p>Components can define default classes. For example in the Components section of the tutorial, we define a Card component:</p> <pre><code>@t.component()\nclass Card(Component):\n    ...\n\n    default_classes = [\"card\"]\n\n    ...\n</code></pre> <p>The <code>default_classes</code> attribute tells PuePy to render the component with card as a default class. Code using the Card component can add to or even remove the default classes defined by the component.</p> <p>To remove a class, pass it with a \"/\" prefix:</p> <pre><code>class MyPage(Page):\n    def populate(self):\n        # This will render as a div with both \"card\" and \"card-blue\" \n        # classes.\n        t.card(classes=\"card-blue\")\n\n        # This will override the default and remove the \"card\" class\n        t.card(classes=\"/card\")        \n</code></pre>"},{"location":"guide/in-depth-components/","title":"In-Depth Components","text":"<p>Defining components in PuePy is a powerful way to encapsulate data, display, and logic in a reusable way. Components become usable like tags in the <code>populate()</code> method of other components or pages, define slots, props, and events.</p>"},{"location":"guide/in-depth-components/#data-flow-features","title":"Data flow features","text":""},{"location":"guide/in-depth-components/#slots","title":"Slots","text":"<p>Slots are a mechanism to allow parent components to inject content (tags, other components, etc) into child components in specified locations. There can be one default or unamed slot, and any number of named slots. </p> <ul> <li>Slots are defined in the <code>populate()</code> method of a component or page using <code>self.insert_slot</code>. </li> <li>Slots are consumed in the code using the component with a context manager object and <code>&lt;component&gt;.slot()</code>.</li> </ul> <p>See the Components Tutorial Chapter for more information on slots.</p>"},{"location":"guide/in-depth-components/#props","title":"Props","text":"<p>Props are a way to pass data to child components. Props must be defined by a component. When writing a component, you can simply include props as a list of strings, where each element is the name of a prop, or include instances of the <code>Prop</code> class. You can mix and match the two as well</p> <pre><code>class MyComponent(Component):\n    props = [\n        \"title\",  # (1)!\n        Prop(\"author_name\", \"Name of Author\", str, \"Unknown\") # (2)!\n    ]\n</code></pre> <ol> <li>This is a prop which only defines a name.</li> <li>To add extra metadata about a prop, you can also define a Prop instance.</li> </ol> <p>Regardless of how you define props in your component, a full \"expanded\" list of props is available on <code>self.props_expanded</code> as a dictionary mapping prop name to <code>Prop</code> instance, with the Prop instance created automatically if only a name is specified.</p> <p>See Also</p> <ul> <li>Prop Class Reference</li> </ul>"},{"location":"guide/in-depth-components/#attributes","title":"Attributes","text":"<p>Keyword arguments passed to a component that do not match any known prop are considered attributes and stored in <code>self.attrs</code>. They are then inserted into the rendered DOM as HTML elements on the rendered attribute. This means that, for instance, you can pass arbitrary HTML attributes to newly created components without defining any custom props or other logic. Eg,</p> <pre><code>from puepy import Component, Page, t\n\n\nclass NameInput(Component):\n    enclosing_tag = \"input\"\n\nclass MyPage(Page):\n    def populate(self):\n        t.name_input(id=\"name_input\", placeholder=\"Enter your name\")\n</code></pre> <p>Even if the NameInput component does not define a <code>placeholder</code> prop, the <code>placeholder</code> attribute will be rendered on the input tag.</p> <p>When to use props vs attributes?</p> <ul> <li>Use props when you want to pass data to a component that will be used in the component's logic or rendering.</li> <li>Use attributes when you want to pass data to a component that will be used in the rendered HTML but not in the component's logic.</li> </ul>"},{"location":"guide/in-depth-components/#events","title":"Events","text":"<p>Events are a way to allow child components to communicate with parent components. When writing a component, in your own code, you can emit an event by calling <code>self.trigger_event</code>. You can also optionally pass a detail dictionary to the event, which will be passed along (after Python to JavaScript conversion) to the browser's native event system in JavaScript.</p> <p>For example, suppose you want to emit a custom event, <code>greeting</code>, with a <code>type</code> attribute:</p> <pre><code>class MyComponent(Component):\n    def some_method(self):\n        self.trigger_event(\"greeting\", detail={\"message\": \"Hello There\"})\n</code></pre> <p>A consumer of your component can listen for this event by defining an <code>on_greeting</code> method in their component or page:</p> <pre><code>class MyPage(Page):\n    def populate(self):\n        t.my_component(on_greeting=self.on_greeting_sent)\n\n    def on_greeting_sent(self, event):\n        print(\"Incoming message from component\", event.detail.get('message'))\n</code></pre> <p>See Also</p> <p>Mozilla's guide to JavaScript events</p>"},{"location":"guide/in-depth-components/#customization","title":"Customization","text":"<p>You have several ways of controlling how your components are rendered. First, you can define what enclosing tag your component is rendered as. The default is a <code>div</code> tag, but this can be overridden:</p> <pre><code>class MyInputComponent(Component):\n    enclosing_tag = \"input\"\n</code></pre> <p>You can also define default classes, default attributes, and the default role for your component:</p> <pre><code>class MyInputComponent(Component):\n    enclosing_tag = \"input\"\n\n    default_classes = [\"my-input\"]\n    default_attributes = {\"type\": \"text\"}\n    default_role = \"textbox\"\n</code></pre>"},{"location":"guide/in-depth-components/#parentchild-relationships","title":"Parent/Child relationships","text":"<p>Each tag (and thus each component) in PuePy has a parent unless it is the root page. Consider the following example:</p> <pre><code>from puepy import Application, Page, Component, t\n\napp = Application()\n\n\n@t.component()\nclass CustomInput(Component):\n    enclosing_tag = \"input\"\n\n    def on_event_handle(self, event):\n        print(self.parent)\n\n\nclass MyPage(Page):\n    def populate(self):\n        with t.div():\n            t.custom_input()\n</code></pre> <p>In this example, the parent of the <code>CustomInput</code> instance is not the <code>MyPage</code> instance, it is the <code>div</code>, a <code>puepy.Tag</code> instance. In many cases, you will want to interact another relevant object, not necessarily the one immediately parental of your current instance. In those instances, from your components, you may reference:</p> <ul> <li><code>self.page</code> (Page instance): The page ultimately responsible for rendering this component</li> <li><code>self.origin</code> (Component or Page instance): The component that created yours in its <code>populate()</code> method </li> <li><code>self.parent</code> (Tag instance): The direct parent of the current instance </li> </ul> <p>Additionally, parent instances have the following available:</p> <ul> <li><code>self.children</code> (list): Direct child nodes</li> <li><code>self.refs</code> (dict): Instances created during this instance's most recent <code>populate()</code> method</li> </ul> <p>Warning</p> <p>None of the attributes regarding parent/child/origin relationships should be modified by application code.  Doing so could result in unexpected behavior.</p>"},{"location":"guide/in-depth-components/#refs","title":"Refs","text":"<p>In addition to parent/child relationships, most components and pages define an entire hierarchy of tags and components in the <code>populate()</code> method. If you want to reference components later, or tell PuePy which component is which (in case the ordering changes in sebsequent redraws), using a <code>ref=</code> argument when building tags:</p> <pre><code>class MyPage(Page):\n    def populate(self):\n        t.button(\"My Button\", ref=\"my_button\")\n\n    def auto_click_button(self, ...):\n        self.refs[\"my_button\"].element.click()\n</code></pre> <p>For more information on why this is useful, see the Refs Tutorial Topic.</p>"},{"location":"guide/pyscript-config/","title":"PyScript Config","text":"<p>PyScript's configuration is fully documented in the PyScript documentation. Configuration for PuePy simply requires adding the PuePy runtime files (see Quick Start - Installation) and Morphdom:</p> <pre><code>{\n  \"name\": \"PuePy Tutorial\",\n  \"debug\": true,\n  \"packages\": [\n    \"./puepy-0.6.2-py3-none-any.whl\"\n  ],\n  \"js_modules\": {\n    \"main\": {\n      \"https://cdn.jsdelivr.net/npm/morphdom@2.7.4/+esm\": \"morphdom\"\n    }\n  }\n}\n</code></pre>"},{"location":"guide/reactivity/","title":"Reactivity","text":"<p>Reactivity is a paradigm that causes the user interface to update automatically in response to changes in the application state. Rather than triggering updates manually as a programmer, you can be assured that the application state will trigger redraws, with new information, as needed. Reactivity in PuePy is inspired by Vue.js.</p>"},{"location":"guide/reactivity/#state","title":"State","text":""},{"location":"guide/reactivity/#initial-state","title":"Initial state","text":"<p>Components (including Pages) define initial state through the <code>initial()</code> method:</p> <pre><code>class MyComponent(Component):\n    def initial(self):\n        return {\n            \"name\": \"Monty ... Something?\",\n            \"movies\": [\"Monty Python and the Holy Grail\"]\n        }\n</code></pre>"},{"location":"guide/reactivity/#modifying-state","title":"Modifying state","text":"<p>If any method on the component changed the name, it would trigger a UI refresh:</p> <pre><code>class MyComponent(Component):\n    def update_name(self):\n        # This triggers a refresh\n        self.state[\"name\"] = \"Monty Python\"\n</code></pre>"},{"location":"guide/reactivity/#modifying-mutable-objects-in-place","title":"Modifying mutable objects in-place","text":"<p>Warnign</p> <p>PuePy's reactivity works by using dictionary <code>__setitem__</code> and <code>__delitem__</code> methods. As such, it cannot detect \"nested\" updates or changes to mutable objects in the state. If your code will result in a state change such as a data structure being changed in-place, you must a <code>mutate()</code> context manager.</p> <p>Modifying complex (mutable) data structures in place without setting them will not work:</p> <pre><code>class MyComponent(Component):\n    def update_movies(self):\n        # THIS WILL NOT CAUSE A UI REFRESH!\n        self.state[\"movies\"].append(\"Monty Python\u2019s Life of Brian\")\n</code></pre> <p>Instead, use a context manager to tell the state object what is being modified. This is ideal anyway.</p> <pre><code>class MyComponent(Component):\n    def update_movies(self):\n        # THIS WILL NOT CAUSE A UI REFRESH!\n        with self.state.mutate(\"movies\"):\n            self.state[\"movies\"].append(\"Monty Python\u2019s Life of Brian\")\n</code></pre> <p><code>mutate(*keys)</code> can be called with any number of keys you intend to modify. As an added benefit, the state change will only call listeners after the context manager exits, making it ideal also for \"batching up\" changes.</p>"},{"location":"guide/reactivity/#controlling-ui-refresh","title":"Controlling UI Refresh","text":""},{"location":"guide/reactivity/#disabling-automatic-refresh","title":"Disabling Automatic Refresh","text":"<p>By default, any detected mutations to a component's state will trigger a UI fresh. This can be customized. To disable automatic refresh entirely, set <code>redraw_on_changes</code> to False.</p> <pre><code>class MyComponent(Component):\n    # The UI will no longer refresh on state changes\n    redraw_on_changes = False\n\n    def something_happened(self):\n        # This can be called to manually refresh this component and its children\n        self.trigger_redraw()\n\n        # Or, you can redraw the whole page\n        self.page.trigger_redraw()\n</code></pre>"},{"location":"guide/reactivity/#limiting-automatic-refresh","title":"Limiting Automatic Refresh","text":"<p>Suppose that you want to refresh the UI on some state changes, but not others.</p> <pre><code>class MyComponent(Component):\n    # When items in this this change, the UI will be redrawn\n    redraw_on_changes = [\"items\"]\n</code></pre>"},{"location":"guide/reactivity/#watching-for-changes","title":"Watching for changes","text":"<p>You can watch for changes in state yourself.</p> <pre><code>class MyComponent(Component):\n    def initial():\n        return {\"spam\": \"eggs\"}\n\n    def on_spam_change(self, new_value):\n        print(\"New value for spam\", new_value)\n</code></pre> <p>Or, watch for any state change:</p> <pre><code>class MyComponent(Component):\n    def on_state_change(self, key, value):\n        print(key, \"was set to\", value)\n</code></pre>"},{"location":"guide/reactivity/#binding-form-element-values-to-state","title":"Binding form element values to state","text":"<p>For your convenience, the <code>bind</code> parameter can be used to automatically establish a two-way connection between input elements and component state. When the value of a form element changes, the state is updated. When the state is updated, the corresponding form tag's value reflects that change.</p> <pre><code>class MyComponent(Component):\n    def initial(self):\n        return {\"name\": \"\"}\n\n    def populate(self):\n        # bind specifies what key on self.state should be tied to this input's value\n        t.input(placeholder=\"Type your name\", bind=\"name\")\n</code></pre>"},{"location":"guide/reactivity/#application-state","title":"Application State","text":"<p>In addition to components and pages, there is also a \"global\" application-wide state. Note that this state is only for a running Application instance and does not survive reloads nor is it shared across multiple browser tabs or windows.</p> <p>To use the application state, use <code>application.state</code> as you would local state. For example, in the Full App Template tutorial chapter, the working example uses  <code>self.application.state[\"authenticated_user\"]</code> in a variety of places:</p> Navigation Guard<pre><code>def precheck(self):\n    if not self.application.state[\"authenticated_user\"]:\n        raise exceptions.Unauthorized()\n</code></pre> Setting state<pre><code>self.application.state[\"authenticated_user\"] = self.state[\"username\"]\n</code></pre> Rendering based on application state<pre><code>def populate(self):\n    ...\n\n    t.h1(f\"Hello, you are authenticated as {self.application.state['authenticated_user']}\")\n</code></pre> <p>As with page or component state, changes to the application state trigger refreshes by default. That behavior can be controlled with <code>redraw_on_app_state_changes</code> on components or pages:</p> <pre><code>class Page1(Page):\n    redraw_on_app_state_changes = True  # (1)!\n\n\nclass Page2(Page):\n    redraw_on_app_state_changes = False  # (2)!\n\n\nclass Page3(Page):\n    redraw_on_app_state_changes = [\"authenticated_user\"]  # (3)!\n</code></pre> <ol> <li>The default behavior, with <code>redraw_on_app_state_changes</code> set to True, all changes to application state trigger a redraw.</li> <li>Setting <code>redraw_on_app_state_changes</code> to False prevents changes to application state from triggering a redraw.</li> <li>Setting <code>redraw_on_app_state_changes</code> to a list of keys will trigger a redraw only when those keys change.</li> </ol> <p>Tip</p> <p>This behavior mirrors <code>redraw_on_state_changes</code>, which is used for local state.</p>"},{"location":"guide/runtimes/","title":"Runtimes","text":"<p>From its upstream project, PyScript, PuePy supports two runtime environments:</p> <ul> <li>MicroPython</li> <li>Pyodide</li> </ul> <p>There are some interface differences, as well as technical ones, described in the official PyScript docs. Additionally, many standard library features are missing from MicroPython. MicroPython does not have access to PyPi packages, nor does MicroPython type hinting or other advanced features as thoroughly as Pyodide.</p> <p>MicroPython, however, has just a ~170k runtime, making it small enough to load on \"normal\" websites without the performance hit of Pyodide's 11MB runtime. It is ideal for situations where webpage response time is important.</p>"},{"location":"guide/runtimes/#when-to-use-pyodide","title":"When to use Pyodide","text":"<p>You may consider using Pyodide when:</p> <ul> <li>Initial load time is less important</li> <li>You need to use PyPi packages</li> <li>You need to use advanced Python features</li> <li>You need to use the full Python standard library</li> <li>You need to use type hinting</li> <li>You need to use Python 3.9 or later</li> </ul>"},{"location":"guide/runtimes/#when-to-use-micropython","title":"When to use MicroPython","text":"<p>You may consider using MicroPython when:</p> <ul> <li>Initial load time is important</li> <li>Your PuePy code will use only simple Python features to add reactivity and interactivity to websites</li> </ul>"},{"location":"guide/runtimes/#how-to-switch-runtimes","title":"How to switch runtimes","text":"<p>To choose a runtime, specify either <code>type=\"mpy\"</code> or <code>type=\"py\"</code> in your <code>&lt;script&gt;</code> tag when loading PuePy. For example:</p>"},{"location":"guide/runtimes/#loading-pyodide","title":"Loading Pyodide","text":"<pre><code>&lt;script type=\"mpy\" src=\"./main.py\" config=\"pyscript.json\"&gt;&lt;/script&gt;\n</code></pre>"},{"location":"guide/runtimes/#loading-micropython","title":"Loading MicroPython","text":"<pre><code>&lt;script type=\"mpy\" src=\"./main.py\" config=\"pyscript.json\"&gt;&lt;/script&gt;\n</code></pre> <p>See Also</p> <ul> <li>PyScript Architecture: Interpreters</li> <li>Pyodide Project</li> <li>MicroPython Project</li> </ul>"},{"location":"reference/application/","title":"puepy.Application","text":"<p>The <code>puepy.Application</code> class is a core part of PuePy. It is the main entry point for creating PuePy applications. The <code>Application</code> class is used to manage the application's state, components, and pages.</p> <p>               Bases: <code>Stateful</code></p> <p>The main application class for PuePy. It manages the state, storage, router, and pages for the application.</p> <p>Attributes:</p> Name Type Description <code>state</code> <code>ReactiveDict</code> <p>The state object for the application.</p> <code>session_storage</code> <code>BrowserStorage</code> <p>The session storage object for the application.</p> <code>local_storage</code> <code>BrowserStorage</code> <p>The local storage object for the application.</p> <code>router</code> <code>Router</code> <p>The router object for the application, if any</p> <code>default_page</code> <code>Page</code> <p>The default page to mount if no route is matched.</p> <code>active_page</code> <code>Page</code> <p>The currently active page.</p> <code>not_found_page</code> <code>Page</code> <p>The page to mount when a 404 error occurs.</p> <code>forbidden_page</code> <code>Page</code> <p>The page to mount when a 403 error occurs.</p> <code>unauthorized_page</code> <code>Page</code> <p>The page to mount when a 401 error occurs.</p> <code>error_page</code> <code>Page</code> <p>The page to mount when an error occurs.</p> Source code in <code>puepy/application.py</code> <pre><code>class Application(Stateful):\n    \"\"\"\n    The main application class for PuePy. It manages the state, storage, router, and pages for the application.\n\n    Attributes:\n        state (ReactiveDict): The state object for the application.\n        session_storage (BrowserStorage): The session storage object for the application.\n        local_storage (BrowserStorage): The local storage object for the application.\n        router (Router): The router object for the application, if any\n        default_page (Page): The default page to mount if no route is matched.\n        active_page (Page): The currently active page.\n        not_found_page (Page): The page to mount when a 404 error occurs.\n        forbidden_page (Page): The page to mount when a 403 error occurs.\n        unauthorized_page (Page): The page to mount when a 401 error occurs.\n        error_page (Page): The page to mount when an error occurs.\n    \"\"\"\n\n    def __init__(self, element_id_generator=None):\n        self.state = ReactiveDict(self.initial())\n        self.add_context(\"state\", self.state)\n\n        if is_server_side:\n            self.session_storage = None\n            self.local_storage = None\n        else:\n            from js import localStorage, sessionStorage\n\n            self.session_storage = BrowserStorage(sessionStorage, \"session_storage\")\n            self.local_storage = BrowserStorage(localStorage, \"local_storage\")\n        self.router = None\n        self._selector_or_element = None\n        self.default_page = None\n        self.active_page = None\n\n        self.not_found_page = GenericErrorPage\n        self.forbidden_page = GenericErrorPage\n        self.unauthorized_page = GenericErrorPage\n        self.error_page = TracebackErrorPage\n\n        self.element_id_generator = element_id_generator or DefaultIdGenerator()\n\n    def install_router(self, router_class, **kwargs):\n        \"\"\"\n        Install a router in the application.\n\n        Args:\n            router_class (class): A class that implements the router logic for the application. At this time, only\n                `puepy.router.Router` is available.\n            **kwargs: Additional keyword arguments that can be passed to the router_class constructor.\n        \"\"\"\n        self.router = router_class(application=self, **kwargs)\n        if not is_server_side:\n            add_event_listener(window, \"popstate\", self._on_popstate)\n\n    def page(self, route=None, name=None):\n        \"\"\"\n        A decorator for `Page` classes which adds the page to the application with a specified route and name.\n\n        Intended to be called as a decorator.\n\n        Args:\n            route (str): The route for the page. Default is None.\n            name (str): The name of the page. If left None, page class is used as the name.\n\n        Examples:\n            ``` py\n            app = Application()\n            @app.page(\"/my-page\")\n            class MyPage(Page):\n                ...\n            ```\n        \"\"\"\n        if route:\n            if not self.router:\n                raise Exception(\"Router not installed\")\n\n            def decorator(func):\n                self.router.add_route(route, func, name=name)\n                return func\n\n            return decorator\n        else:\n\n            def decorator(func):\n                self.default_page = func\n                return func\n\n            return decorator\n\n    def _on_popstate(self, event):\n        if self.router.link_mode == self.router.LINK_MODE_HASH:\n            self.mount(self._selector_or_element, window.location.hash.split(\"#\", 1)[-1])\n        elif self.router.link_mode in (self.router.LINK_MODE_DIRECT, self.router.LINK_MODE_HTML5):\n            self.mount(self._selector_or_element, window.location.pathname)\n\n    def remount(self, path=None, page_kwargs=None):\n        \"\"\"\n        Remounts the selected element or selector with the specified path and page_kwargs.\n\n        Args:\n            path (str): The new path to be used for remounting the element or selector. Default is None.\n            page_kwargs (dict): Additional page kwargs to be passed when remounting. Default is None.\n\n        \"\"\"\n        self.mount(self._selector_or_element, path=path, page_kwargs=page_kwargs)\n\n    def mount(self, selector_or_element, path=None, page_kwargs=None):\n        \"\"\"\n        Mounts a page onto the specified selector or element with optional path and page_kwargs.\n\n        Args:\n            selector_or_element: The selector or element on which to mount the page.\n            path: Optional path to match against the router. Defaults to None.\n            page_kwargs: Optional keyword arguments to pass to the mounted page. Defaults to None.\n\n        Returns:\n            (Page): The mounted page instance\n        \"\"\"\n        if page_kwargs is None:\n            page_kwargs = {}\n\n        self._selector_or_element = selector_or_element\n\n        if self.router:\n            path = path or self.current_path\n            route, arguments = self.router.match(path)\n            if arguments:\n                page_kwargs.update(arguments)\n\n            if route:\n                page_class = route.page\n            elif path in (\"\", \"/\") and self.default_page:\n                page_class = self.default_page\n            elif self.not_found_page:\n                page_class = self.not_found_page\n            else:\n                return None\n        elif self.default_page:\n            route = None\n            page_class = self.default_page\n        else:\n            return None\n\n        self.active_page = None\n        try:\n            self.mount_page(\n                selector_or_element=selector_or_element,\n                page_class=page_class,\n                route=route,\n                page_kwargs=page_kwargs,\n                handle_exceptions=True,\n            )\n        except Exception as e:\n            self.handle_error(e)\n        return self.active_page\n\n    @property\n    def current_path(self):\n        \"\"\"\n        Returns the current path based on the router's link mode.\n\n        Returns:\n            str: The current path.\n        \"\"\"\n        if self.router.link_mode == self.router.LINK_MODE_HASH:\n            return window.location.hash.split(\"#\", 1)[-1]\n        elif self.router.link_mode in (self.router.LINK_MODE_DIRECT, self.router.LINK_MODE_HTML5):\n            return window.location.pathname\n        else:\n            return \"\"\n\n    def mount_page(self, selector_or_element, page_class, route, page_kwargs, handle_exceptions=True):\n        \"\"\"\n        Mounts a page on the specified selector or element with the given parameters.\n\n        Args:\n            selector_or_element (str or Element): The selector string or element to mount the page on.\n            page_class (class): The page class to mount.\n            route (str): The route for the page.\n            page_kwargs (dict): Additional keyword arguments to pass to the page class.\n            handle_exceptions (bool, optional): Determines whether to handle exceptions thrown during mounting.\n                Defaults to True.\n        \"\"\"\n        page_class._expanded_props()\n\n        # For security, we only pass props to the page that are defined in the page's props\n        #\n        # We also handle the list or not-list props for multiple or single values\n        # (eg, ?foo=1&amp;foo=2 -&gt; [\"1\", \"2\"] if needed)\n        #\n        prop_args = {}\n        prop: Prop\n        for prop in page_class.props_expanded.values():\n            if prop.name in page_kwargs:\n                value = page_kwargs.pop(prop.name)\n                if prop.type is list:\n                    prop_args[prop.name] = value if isinstance(value, list) else [value]\n                else:\n                    prop_args[prop.name] = value if not isinstance(value, list) else value[0]\n\n        self.active_page: Page = page_class(matched_route=route, application=self, extra_args=page_kwargs, **prop_args)\n        try:\n            self.active_page.mount(selector_or_element)\n        except exceptions.PageError as e:\n            if handle_exceptions:\n                self.handle_page_error(e)\n            else:\n                raise\n\n    def handle_page_error(self, exc):\n        \"\"\"\n        Handles page error based on the given exception by inspecting the exception type and passing it along to one\n        of:\n\n        - `handle_not_found`\n        - `handle_forbidden`\n        - `handle_unauthorized`\n        - `handle_redirect`\n        - `handle_error`\n\n        Args:\n            exc (Exception): The exception object representing the page error.\n        \"\"\"\n        if isinstance(exc, exceptions.NotFound):\n            self.handle_not_found(exc)\n        elif isinstance(exc, exceptions.Forbidden):\n            self.handle_forbidden(exc)\n        elif isinstance(exc, exceptions.Unauthorized):\n            self.handle_unauthorized(exc)\n        elif isinstance(exc, exceptions.Redirect):\n            self.handle_redirect(exc)\n        else:\n            self.handle_error(exc)\n\n    def handle_not_found(self, exception):\n        \"\"\"\n        Handles the exception for not found page. By default, it mounts the self.not_found_page class and passes it\n        the exception as an argument.\n\n        Args:\n            exception (Exception): The exception that occurred.\n        \"\"\"\n        self.mount_page(\n            self._selector_or_element, self.not_found_page, None, {\"error\": exception}, handle_exceptions=False\n        )\n\n    def handle_forbidden(self, exception):\n        \"\"\"\n        Handles the exception for forbidden page. By default, it mounts the self.forbidden_page class and passes it\n        the exception as an argument.\n\n        Args:\n            exception (Exception): The exception that occurred.\n        \"\"\"\n        self.mount_page(\n            self._selector_or_element,\n            self.forbidden_page,\n            None,\n            {\"error\": exception},\n            handle_exceptions=False,\n        )\n\n    def handle_unauthorized(self, exception):\n        \"\"\"\n        Handles the exception for unauthorized page. By default, it mounts the self.unauthorized_page class and passes it\n        the exception as an argument.\n\n        Args:\n            exception (Exception): The exception that occurred.\n        \"\"\"\n        self.mount_page(\n            self._selector_or_element, self.unauthorized_page, None, {\"error\": exception}, handle_exceptions=False\n        )\n\n    def handle_error(self, exception):\n        \"\"\"\n        Handles the exception for application or unknown errors. By default, it mounts the self.error_page class and\n        passes it the exception as an argument.\n\n        Args:\n            exception (Exception): The exception that occurred.\n        \"\"\"\n        self.mount_page(self._selector_or_element, self.error_page, None, {\"error\": exception}, handle_exceptions=False)\n        if is_server_side:\n            raise\n\n    def handle_redirect(self, exception):\n        \"\"\"\n        Handles a redirect exception by navigating to the given path.\n\n        Args:\n            exception (RedirectException): The redirect exception containing the path to navigate to.\n        \"\"\"\n        self.router.navigate_to_path(exception.path)\n</code></pre>"},{"location":"reference/application/#puepy.Application.current_path","title":"<code>current_path</code>  <code>property</code>","text":"<p>Returns the current path based on the router's link mode.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>The current path.</p>"},{"location":"reference/application/#puepy.Application.handle_error","title":"<code>handle_error(exception)</code>","text":"<p>Handles the exception for application or unknown errors. By default, it mounts the self.error_page class and passes it the exception as an argument.</p> <p>Parameters:</p> Name Type Description Default <code>exception</code> <code>Exception</code> <p>The exception that occurred.</p> required Source code in <code>puepy/application.py</code> <pre><code>def handle_error(self, exception):\n    \"\"\"\n    Handles the exception for application or unknown errors. By default, it mounts the self.error_page class and\n    passes it the exception as an argument.\n\n    Args:\n        exception (Exception): The exception that occurred.\n    \"\"\"\n    self.mount_page(self._selector_or_element, self.error_page, None, {\"error\": exception}, handle_exceptions=False)\n    if is_server_side:\n        raise\n</code></pre>"},{"location":"reference/application/#puepy.Application.handle_forbidden","title":"<code>handle_forbidden(exception)</code>","text":"<p>Handles the exception for forbidden page. By default, it mounts the self.forbidden_page class and passes it the exception as an argument.</p> <p>Parameters:</p> Name Type Description Default <code>exception</code> <code>Exception</code> <p>The exception that occurred.</p> required Source code in <code>puepy/application.py</code> <pre><code>def handle_forbidden(self, exception):\n    \"\"\"\n    Handles the exception for forbidden page. By default, it mounts the self.forbidden_page class and passes it\n    the exception as an argument.\n\n    Args:\n        exception (Exception): The exception that occurred.\n    \"\"\"\n    self.mount_page(\n        self._selector_or_element,\n        self.forbidden_page,\n        None,\n        {\"error\": exception},\n        handle_exceptions=False,\n    )\n</code></pre>"},{"location":"reference/application/#puepy.Application.handle_not_found","title":"<code>handle_not_found(exception)</code>","text":"<p>Handles the exception for not found page. By default, it mounts the self.not_found_page class and passes it the exception as an argument.</p> <p>Parameters:</p> Name Type Description Default <code>exception</code> <code>Exception</code> <p>The exception that occurred.</p> required Source code in <code>puepy/application.py</code> <pre><code>def handle_not_found(self, exception):\n    \"\"\"\n    Handles the exception for not found page. By default, it mounts the self.not_found_page class and passes it\n    the exception as an argument.\n\n    Args:\n        exception (Exception): The exception that occurred.\n    \"\"\"\n    self.mount_page(\n        self._selector_or_element, self.not_found_page, None, {\"error\": exception}, handle_exceptions=False\n    )\n</code></pre>"},{"location":"reference/application/#puepy.Application.handle_page_error","title":"<code>handle_page_error(exc)</code>","text":"<p>Handles page error based on the given exception by inspecting the exception type and passing it along to one of:</p> <ul> <li><code>handle_not_found</code></li> <li><code>handle_forbidden</code></li> <li><code>handle_unauthorized</code></li> <li><code>handle_redirect</code></li> <li><code>handle_error</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>Exception</code> <p>The exception object representing the page error.</p> required Source code in <code>puepy/application.py</code> <pre><code>def handle_page_error(self, exc):\n    \"\"\"\n    Handles page error based on the given exception by inspecting the exception type and passing it along to one\n    of:\n\n    - `handle_not_found`\n    - `handle_forbidden`\n    - `handle_unauthorized`\n    - `handle_redirect`\n    - `handle_error`\n\n    Args:\n        exc (Exception): The exception object representing the page error.\n    \"\"\"\n    if isinstance(exc, exceptions.NotFound):\n        self.handle_not_found(exc)\n    elif isinstance(exc, exceptions.Forbidden):\n        self.handle_forbidden(exc)\n    elif isinstance(exc, exceptions.Unauthorized):\n        self.handle_unauthorized(exc)\n    elif isinstance(exc, exceptions.Redirect):\n        self.handle_redirect(exc)\n    else:\n        self.handle_error(exc)\n</code></pre>"},{"location":"reference/application/#puepy.Application.handle_redirect","title":"<code>handle_redirect(exception)</code>","text":"<p>Handles a redirect exception by navigating to the given path.</p> <p>Parameters:</p> Name Type Description Default <code>exception</code> <code>RedirectException</code> <p>The redirect exception containing the path to navigate to.</p> required Source code in <code>puepy/application.py</code> <pre><code>def handle_redirect(self, exception):\n    \"\"\"\n    Handles a redirect exception by navigating to the given path.\n\n    Args:\n        exception (RedirectException): The redirect exception containing the path to navigate to.\n    \"\"\"\n    self.router.navigate_to_path(exception.path)\n</code></pre>"},{"location":"reference/application/#puepy.Application.handle_unauthorized","title":"<code>handle_unauthorized(exception)</code>","text":"<p>Handles the exception for unauthorized page. By default, it mounts the self.unauthorized_page class and passes it the exception as an argument.</p> <p>Parameters:</p> Name Type Description Default <code>exception</code> <code>Exception</code> <p>The exception that occurred.</p> required Source code in <code>puepy/application.py</code> <pre><code>def handle_unauthorized(self, exception):\n    \"\"\"\n    Handles the exception for unauthorized page. By default, it mounts the self.unauthorized_page class and passes it\n    the exception as an argument.\n\n    Args:\n        exception (Exception): The exception that occurred.\n    \"\"\"\n    self.mount_page(\n        self._selector_or_element, self.unauthorized_page, None, {\"error\": exception}, handle_exceptions=False\n    )\n</code></pre>"},{"location":"reference/application/#puepy.Application.install_router","title":"<code>install_router(router_class, **kwargs)</code>","text":"<p>Install a router in the application.</p> <p>Parameters:</p> Name Type Description Default <code>router_class</code> <code>class</code> <p>A class that implements the router logic for the application. At this time, only <code>puepy.router.Router</code> is available.</p> required <code>**kwargs</code> <p>Additional keyword arguments that can be passed to the router_class constructor.</p> <code>{}</code> Source code in <code>puepy/application.py</code> <pre><code>def install_router(self, router_class, **kwargs):\n    \"\"\"\n    Install a router in the application.\n\n    Args:\n        router_class (class): A class that implements the router logic for the application. At this time, only\n            `puepy.router.Router` is available.\n        **kwargs: Additional keyword arguments that can be passed to the router_class constructor.\n    \"\"\"\n    self.router = router_class(application=self, **kwargs)\n    if not is_server_side:\n        add_event_listener(window, \"popstate\", self._on_popstate)\n</code></pre>"},{"location":"reference/application/#puepy.Application.mount","title":"<code>mount(selector_or_element, path=None, page_kwargs=None)</code>","text":"<p>Mounts a page onto the specified selector or element with optional path and page_kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>selector_or_element</code> <p>The selector or element on which to mount the page.</p> required <code>path</code> <p>Optional path to match against the router. Defaults to None.</p> <code>None</code> <code>page_kwargs</code> <p>Optional keyword arguments to pass to the mounted page. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Page</code> <p>The mounted page instance</p> Source code in <code>puepy/application.py</code> <pre><code>def mount(self, selector_or_element, path=None, page_kwargs=None):\n    \"\"\"\n    Mounts a page onto the specified selector or element with optional path and page_kwargs.\n\n    Args:\n        selector_or_element: The selector or element on which to mount the page.\n        path: Optional path to match against the router. Defaults to None.\n        page_kwargs: Optional keyword arguments to pass to the mounted page. Defaults to None.\n\n    Returns:\n        (Page): The mounted page instance\n    \"\"\"\n    if page_kwargs is None:\n        page_kwargs = {}\n\n    self._selector_or_element = selector_or_element\n\n    if self.router:\n        path = path or self.current_path\n        route, arguments = self.router.match(path)\n        if arguments:\n            page_kwargs.update(arguments)\n\n        if route:\n            page_class = route.page\n        elif path in (\"\", \"/\") and self.default_page:\n            page_class = self.default_page\n        elif self.not_found_page:\n            page_class = self.not_found_page\n        else:\n            return None\n    elif self.default_page:\n        route = None\n        page_class = self.default_page\n    else:\n        return None\n\n    self.active_page = None\n    try:\n        self.mount_page(\n            selector_or_element=selector_or_element,\n            page_class=page_class,\n            route=route,\n            page_kwargs=page_kwargs,\n            handle_exceptions=True,\n        )\n    except Exception as e:\n        self.handle_error(e)\n    return self.active_page\n</code></pre>"},{"location":"reference/application/#puepy.Application.mount_page","title":"<code>mount_page(selector_or_element, page_class, route, page_kwargs, handle_exceptions=True)</code>","text":"<p>Mounts a page on the specified selector or element with the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>selector_or_element</code> <code>str or Element</code> <p>The selector string or element to mount the page on.</p> required <code>page_class</code> <code>class</code> <p>The page class to mount.</p> required <code>route</code> <code>str</code> <p>The route for the page.</p> required <code>page_kwargs</code> <code>dict</code> <p>Additional keyword arguments to pass to the page class.</p> required <code>handle_exceptions</code> <code>bool</code> <p>Determines whether to handle exceptions thrown during mounting. Defaults to True.</p> <code>True</code> Source code in <code>puepy/application.py</code> <pre><code>def mount_page(self, selector_or_element, page_class, route, page_kwargs, handle_exceptions=True):\n    \"\"\"\n    Mounts a page on the specified selector or element with the given parameters.\n\n    Args:\n        selector_or_element (str or Element): The selector string or element to mount the page on.\n        page_class (class): The page class to mount.\n        route (str): The route for the page.\n        page_kwargs (dict): Additional keyword arguments to pass to the page class.\n        handle_exceptions (bool, optional): Determines whether to handle exceptions thrown during mounting.\n            Defaults to True.\n    \"\"\"\n    page_class._expanded_props()\n\n    # For security, we only pass props to the page that are defined in the page's props\n    #\n    # We also handle the list or not-list props for multiple or single values\n    # (eg, ?foo=1&amp;foo=2 -&gt; [\"1\", \"2\"] if needed)\n    #\n    prop_args = {}\n    prop: Prop\n    for prop in page_class.props_expanded.values():\n        if prop.name in page_kwargs:\n            value = page_kwargs.pop(prop.name)\n            if prop.type is list:\n                prop_args[prop.name] = value if isinstance(value, list) else [value]\n            else:\n                prop_args[prop.name] = value if not isinstance(value, list) else value[0]\n\n    self.active_page: Page = page_class(matched_route=route, application=self, extra_args=page_kwargs, **prop_args)\n    try:\n        self.active_page.mount(selector_or_element)\n    except exceptions.PageError as e:\n        if handle_exceptions:\n            self.handle_page_error(e)\n        else:\n            raise\n</code></pre>"},{"location":"reference/application/#puepy.Application.page","title":"<code>page(route=None, name=None)</code>","text":"<p>A decorator for <code>Page</code> classes which adds the page to the application with a specified route and name.</p> <p>Intended to be called as a decorator.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>The route for the page. Default is None.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the page. If left None, page class is used as the name.</p> <code>None</code> <p>Examples:</p> <pre><code>app = Application()\n@app.page(\"/my-page\")\nclass MyPage(Page):\n    ...\n</code></pre> Source code in <code>puepy/application.py</code> <pre><code>def page(self, route=None, name=None):\n    \"\"\"\n    A decorator for `Page` classes which adds the page to the application with a specified route and name.\n\n    Intended to be called as a decorator.\n\n    Args:\n        route (str): The route for the page. Default is None.\n        name (str): The name of the page. If left None, page class is used as the name.\n\n    Examples:\n        ``` py\n        app = Application()\n        @app.page(\"/my-page\")\n        class MyPage(Page):\n            ...\n        ```\n    \"\"\"\n    if route:\n        if not self.router:\n            raise Exception(\"Router not installed\")\n\n        def decorator(func):\n            self.router.add_route(route, func, name=name)\n            return func\n\n        return decorator\n    else:\n\n        def decorator(func):\n            self.default_page = func\n            return func\n\n        return decorator\n</code></pre>"},{"location":"reference/application/#puepy.Application.remount","title":"<code>remount(path=None, page_kwargs=None)</code>","text":"<p>Remounts the selected element or selector with the specified path and page_kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The new path to be used for remounting the element or selector. Default is None.</p> <code>None</code> <code>page_kwargs</code> <code>dict</code> <p>Additional page kwargs to be passed when remounting. Default is None.</p> <code>None</code> Source code in <code>puepy/application.py</code> <pre><code>def remount(self, path=None, page_kwargs=None):\n    \"\"\"\n    Remounts the selected element or selector with the specified path and page_kwargs.\n\n    Args:\n        path (str): The new path to be used for remounting the element or selector. Default is None.\n        page_kwargs (dict): Additional page kwargs to be passed when remounting. Default is None.\n\n    \"\"\"\n    self.mount(self._selector_or_element, path=path, page_kwargs=page_kwargs)\n</code></pre>"},{"location":"reference/component/","title":"puepy.Component","text":"<p>Components should not be created directly</p> <p>In your <code>populate()</code> method, call t.tag_name() to create a component. There's no reason an application develop should directly instanciate a component instance and doing so is not supported.</p> <p>See also</p> <ul> <li>Tutorial on Components</li> <li>In-Depth Components Guide</li> </ul> <p>               Bases: <code>Tag</code>, <code>Stateful</code></p> <p>Components are a way of defining reusable and composable elements in PuePy. They are a subclass of Tag, but provide additional features such as state management and props. By defining your own components and registering them, you can create a library of reusable elements for your application.</p> <p>Attributes:</p> Name Type Description <code>enclosing_tag</code> <code>str</code> <p>The tag name that will enclose the component. To be defined as a class attribute on subclasses.</p> <code>component_name</code> <code>str</code> <p>The name of the component. If left blank, class name is used. To be defined as a class attribute on subclasses.</p> <code>redraw_on_state_changes</code> <code>bool</code> <p>Whether the component should redraw when its state changes. To be defined as a class attribute on subclasses.</p> <code>redraw_on_app_state_changes</code> <code>bool</code> <p>Whether the component should redraw when the application state changes. To be defined as a class attribute on subclasses.</p> <code>props</code> <code>list</code> <p>A list of props for the component. To be defined as a class attribute on subclasses.</p> Source code in <code>puepy/core.py</code> <pre><code>class Component(Tag, Stateful):\n    \"\"\"\n    Components are a way of defining reusable and composable elements in PuePy. They are a subclass of Tag, but provide\n    additional features such as state management and props. By defining your own components and registering them, you\n    can create a library of reusable elements for your application.\n\n    Attributes:\n        enclosing_tag (str): The tag name that will enclose the component. To be defined as a class attribute on subclasses.\n        component_name (str): The name of the component. If left blank, class name is used. To be defined as a class attribute on subclasses.\n        redraw_on_state_changes (bool): Whether the component should redraw when its state changes. To be defined as a class attribute on subclasses.\n        redraw_on_app_state_changes (bool): Whether the component should redraw when the application state changes. To be defined as a class attribute on subclasses.\n        props (list): A list of props for the component. To be defined as a class attribute on subclasses.\n    \"\"\"\n\n    enclosing_tag = \"div\"\n    component_name = None\n    redraw_on_state_changes = True\n    redraw_on_app_state_changes = True\n\n    props = []\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, tag_name=self.enclosing_tag, **kwargs)\n        self.state = ReactiveDict(self.initial())\n        self.add_context(\"state\", self.state)\n\n        self.slots = {}\n\n    def _handle_attrs(self, kwargs):\n        self._handle_props(kwargs)\n\n        super()._handle_attrs(kwargs)\n\n    def _handle_props(self, kwargs):\n        if not hasattr(self, \"props_expanded\"):\n            self._expanded_props()\n\n        self.props_values = {}\n        for name, prop in self.props_expanded.items():\n            value = kwargs.pop(prop.name, prop.default_value)\n            setattr(self, name, value)\n            self.props_values[name] = value\n\n    @classmethod\n    def _expanded_props(cls):\n        # This would be ideal for metaprogramming, but we do it this way to be compatible with Micropython. :/\n        props_expanded = {}\n        for prop in cls.props:\n            if isinstance(prop, Prop):\n                props_expanded[prop.name] = prop\n            elif isinstance(prop, dict):\n                props_expanded[prop[\"name\"]] = Prop(**prop)\n            elif isinstance(prop, str):\n                props_expanded[prop] = Prop(name=prop)\n            else:\n                raise PropsError(f\"Unknown prop type {type(prop)}\")\n        cls.props_expanded = props_expanded\n\n    def initial(self):\n        \"\"\"\n        To be overridden in subclasses, the `initial()` method defines the initial state of the component.\n\n        Returns:\n            (dict): Initial component state\n        \"\"\"\n        return {}\n\n    def _on_state_change(self, context, key, value):\n        super()._on_state_change(context, key, value)\n\n        if context == \"state\":\n            redraw_rule = self.redraw_on_state_changes\n        elif context == \"app\":\n            redraw_rule = self.redraw_on_app_state_changes\n        else:\n            return\n\n        if redraw_rule is True:\n            self.page.redraw_tag(self)\n        elif redraw_rule is False:\n            pass\n        elif isinstance(redraw_rule, (list, set)):\n            if key in redraw_rule:\n                self.page.redraw_tag(self)\n        else:\n            raise Exception(f\"Unknown value for redraw rule: {redraw_rule} (context: {context})\")\n\n    def insert_slot(self, name=\"default\", **kwargs):\n        \"\"\"\n        In defining your own component, when you want to create a slot in your `populate` method, you can use this method.\n\n        Args:\n            name (str): The name of the slot. If not passed, the default slot is inserted.\n            **kwargs: Additional keyword arguments to be passed to Slot initialization.\n\n        Returns:\n            Slot: The inserted slot object.\n        \"\"\"\n        if name in self.slots:\n            self.slots[name].parent = Tag.stack[-1]  # The children will be cleared during redraw, so re-establish\n        else:\n            self.slots[name] = Slot(ref=f\"slot={name}\", slot_name=name, page=self.page, parent=Tag.stack[-1], **kwargs)\n        slot = self.slots[name]\n        if self.origin:\n            slot.origin = self.origin\n            if slot.ref:\n                self.origin.refs[slot.ref] = slot\n        return slot\n\n    def slot(self, name=\"default\"):\n        \"\"\"\n        To be used in the `populate` method of code making use of this component, this method returns the slot object\n        with the given name. It should be used inside of a context manager.\n\n        Args:\n            name (str): The name of the slot to clear and return.\n\n        Returns:\n            Slot: The cleared slot object.\n        \"\"\"\n        #\n        # We put this here, so it clears the children only when the slot-filler is doing its filling.\n        # Otherwise, the previous children are kept. Lucky them.\n        self.slots[name].children = []\n        return self.slots[name]\n\n    def __enter__(self):\n        self.stack.append(self)\n        self.origin_stack[0].append(self)\n        self.component_stack.append(self)\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.stack.pop()\n        self.origin_stack[0].pop()\n        self.component_stack.pop()\n        return False\n\n    def __str__(self):\n        return f\"{self.component_name or self.__class__.__name__} ({self.ref} {id(self)})\"\n\n    def __repr__(self):\n        return f\"&lt;{self}&gt;\"\n</code></pre>"},{"location":"reference/component/#puepy.Component.initial","title":"<code>initial()</code>","text":"<p>To be overridden in subclasses, the <code>initial()</code> method defines the initial state of the component.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Initial component state</p> Source code in <code>puepy/core.py</code> <pre><code>def initial(self):\n    \"\"\"\n    To be overridden in subclasses, the `initial()` method defines the initial state of the component.\n\n    Returns:\n        (dict): Initial component state\n    \"\"\"\n    return {}\n</code></pre>"},{"location":"reference/component/#puepy.Component.insert_slot","title":"<code>insert_slot(name='default', **kwargs)</code>","text":"<p>In defining your own component, when you want to create a slot in your <code>populate</code> method, you can use this method.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the slot. If not passed, the default slot is inserted.</p> <code>'default'</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to Slot initialization.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Slot</code> <p>The inserted slot object.</p> Source code in <code>puepy/core.py</code> <pre><code>def insert_slot(self, name=\"default\", **kwargs):\n    \"\"\"\n    In defining your own component, when you want to create a slot in your `populate` method, you can use this method.\n\n    Args:\n        name (str): The name of the slot. If not passed, the default slot is inserted.\n        **kwargs: Additional keyword arguments to be passed to Slot initialization.\n\n    Returns:\n        Slot: The inserted slot object.\n    \"\"\"\n    if name in self.slots:\n        self.slots[name].parent = Tag.stack[-1]  # The children will be cleared during redraw, so re-establish\n    else:\n        self.slots[name] = Slot(ref=f\"slot={name}\", slot_name=name, page=self.page, parent=Tag.stack[-1], **kwargs)\n    slot = self.slots[name]\n    if self.origin:\n        slot.origin = self.origin\n        if slot.ref:\n            self.origin.refs[slot.ref] = slot\n    return slot\n</code></pre>"},{"location":"reference/component/#puepy.Component.slot","title":"<code>slot(name='default')</code>","text":"<p>To be used in the <code>populate</code> method of code making use of this component, this method returns the slot object with the given name. It should be used inside of a context manager.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the slot to clear and return.</p> <code>'default'</code> <p>Returns:</p> Name Type Description <code>Slot</code> <p>The cleared slot object.</p> Source code in <code>puepy/core.py</code> <pre><code>def slot(self, name=\"default\"):\n    \"\"\"\n    To be used in the `populate` method of code making use of this component, this method returns the slot object\n    with the given name. It should be used inside of a context manager.\n\n    Args:\n        name (str): The name of the slot to clear and return.\n\n    Returns:\n        Slot: The cleared slot object.\n    \"\"\"\n    #\n    # We put this here, so it clears the children only when the slot-filler is doing its filling.\n    # Otherwise, the previous children are kept. Lucky them.\n    self.slots[name].children = []\n    return self.slots[name]\n</code></pre>"},{"location":"reference/exceptions/","title":"peupy.exceptions","text":"<p>Common exceptions in the PuePy framework.</p> <p>Classes:</p> Name Description <code>ElementNotInDom</code> <p>Raised when an element is not found in the DOM, but it is expected to be, such as when getting Tag.element</p> <code>PropsError</code> <p>Raised when unexpected props are passed to a component</p> <code>PageError</code> <p>Analogous to http errors, but for a single-page app where the error is client-side</p> <code>NotFound</code> <p>Page not found</p> <code>Forbidden</code> <p>Forbidden</p> <code>Unauthorized</code> <p>Unauthorized</p> <code>Redirect</code> <p>Redirect</p>"},{"location":"reference/exceptions/#puepy.exceptions.ElementNotInDom","title":"<code>ElementNotInDom</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when an element is not found in the DOM, but it is expected to be, such as when getting Tag.element</p> Source code in <code>puepy/exceptions.py</code> <pre><code>class ElementNotInDom(Exception):\n    \"\"\"\n    Raised when an element is not found in the DOM, but it is expected to be, such as when getting Tag.element\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/exceptions/#puepy.exceptions.Forbidden","title":"<code>Forbidden</code>","text":"<p>               Bases: <code>PageError</code></p> <p>Raised manually, presumably when the user is not authorized to access a page.</p> Source code in <code>puepy/exceptions.py</code> <pre><code>class Forbidden(PageError):\n    \"\"\"\n    Raised manually, presumably when the user is not authorized to access a page.\n    \"\"\"\n\n    def __str__(self):\n        return \"Forbidden\"\n</code></pre>"},{"location":"reference/exceptions/#puepy.exceptions.NotFound","title":"<code>NotFound</code>","text":"<p>               Bases: <code>PageError</code></p> <p>Raised when the router could not find a page matching the user's URL.</p> Source code in <code>puepy/exceptions.py</code> <pre><code>class NotFound(PageError):\n    \"\"\"\n    Raised when the router could not find a page matching the user's URL.\n    \"\"\"\n\n    def __str__(self):\n        return \"Page not found\"\n</code></pre>"},{"location":"reference/exceptions/#puepy.exceptions.PageError","title":"<code>PageError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Analogous to http errors, but for a single-page app where the error is client-side</p> Source code in <code>puepy/exceptions.py</code> <pre><code>class PageError(Exception):\n    \"\"\"\n    Analogous to http errors, but for a single-page app where the error is client-side\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/exceptions/#puepy.exceptions.PropsError","title":"<code>PropsError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when unexpected props are passed to a component</p> Source code in <code>puepy/exceptions.py</code> <pre><code>class PropsError(ValueError):\n    \"\"\"\n    Raised when unexpected props are passed to a component\n    \"\"\"\n</code></pre>"},{"location":"reference/exceptions/#puepy.exceptions.Redirect","title":"<code>Redirect</code>","text":"<p>               Bases: <code>PageError</code></p> <p>Raised manually when the user should be redirected to another page.</p> Source code in <code>puepy/exceptions.py</code> <pre><code>class Redirect(PageError):\n    \"\"\"\n    Raised manually when the user should be redirected to another page.\n    \"\"\"\n\n    def __init__(self, path):\n        self.path = path\n\n    def __str__(self):\n        return f\"Redirect to {self.path}\"\n</code></pre>"},{"location":"reference/exceptions/#puepy.exceptions.Unauthorized","title":"<code>Unauthorized</code>","text":"<p>               Bases: <code>PageError</code></p> <p>Raised manually, presumably when the user is not authenticated.</p> Source code in <code>puepy/exceptions.py</code> <pre><code>class Unauthorized(PageError):\n    \"\"\"\n    Raised manually, presumably when the user is not authenticated.\n    \"\"\"\n\n    def __str__(self):\n        return \"Unauthorized\"\n</code></pre>"},{"location":"reference/prop/","title":"puepy.Prop","text":"<p>Class representing a prop for a component.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the property.</p> <code>description</code> <code>str</code> <p>The description of the property (optional).</p> <code>type</code> <code>type</code> <p>The data type of the property (default: str).</p> <code>default_value</code> <p>The default value of the property (optional).</p> Source code in <code>puepy/core.py</code> <pre><code>class Prop:\n    \"\"\"\n    Class representing a prop for a component.\n\n    Attributes:\n        name (str): The name of the property.\n        description (str): The description of the property (optional).\n        type (type): The data type of the property (default: str).\n        default_value: The default value of the property (optional).\n    \"\"\"\n\n    def __init__(self, name, description=None, type=str, default_value=None):\n        self.name = name\n        self.description = description\n        self.type = type\n        self.default_value = default_value\n</code></pre>"},{"location":"reference/reactivity/","title":"puepy.reactivity","text":"<p>Provides the base classes for PuePy's reactivity system independent of web concerns. These classes are not intended to be used directly, but could be useful for implementing a similar system in a different context.</p> <p>Classes:</p> Name Description <code>Listener</code> <p>A simple class that notifies a collection of callback functions when its <code>notify</code> method is called</p> <code>ReactiveDict</code> <p>A dictionary that notifies a listener when it is updated</p>"},{"location":"reference/reactivity/#puepy.reactivity.Listener","title":"<code>Listener</code>","text":"<p>A simple class that allows you to register callbacks and then notify them all at once.</p> <p>Attributes:</p> Name Type Description <code>callbacks</code> <code>list of callables</code> <p>A list of callback functions to be called when <code>notify</code> is called</p> Source code in <code>puepy/reactivity.py</code> <pre><code>class Listener:\n    \"\"\"\n    A simple class that allows you to register callbacks and then notify them all at once.\n\n    Attributes:\n        callbacks (list of callables): A list of callback functions to be called when `notify` is called\n    \"\"\"\n\n    def __init__(self):\n        self.callbacks = []\n\n    def add_callback(self, callback):\n        \"\"\"\n        Adds a callback function to the listener.\n\n        Args:\n            callback (callable): The callback function to be added\n        \"\"\"\n        self.callbacks.append(callback)\n\n    def remove_callback(self, callback):\n        \"\"\"\n        Removes a callback function from the listener.\n\n        Args:\n            callback (callable): The callback to be removed\n        \"\"\"\n        self.callbacks.remove(callback)\n\n    def notify(self, *args, **kwargs):\n        \"\"\"\n        Notify method\n\n        Executes each callback function in the callbacks list by passing in the given arguments and keyword arguments.\n        If an exception occurs during the callback execution, it is logged using the logging library.\n\n        Args:\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n        \"\"\"\n        for callback in self.callbacks:\n            try:\n                callback(*args, **kwargs)\n            except Exception as e:\n                logging.exception(\"Error in callback for {self}: {callback}:\".format(self=self, callback=callback))\n\n    def __str__(self):\n        if len(self.callbacks) == 1:\n            return f\"Listener: {self.callbacks[0]}\"\n        elif len(self.callbacks) &gt; 1:\n            return f\"Listener with {len(self.callbacks)} callbacks\"\n        else:\n            return \"Listener with no callbacks\"\n\n    def __repr__(self):\n        return f\"&lt;{self}&gt;\"\n</code></pre>"},{"location":"reference/reactivity/#puepy.reactivity.Listener.add_callback","title":"<code>add_callback(callback)</code>","text":"<p>Adds a callback function to the listener.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>callable</code> <p>The callback function to be added</p> required Source code in <code>puepy/reactivity.py</code> <pre><code>def add_callback(self, callback):\n    \"\"\"\n    Adds a callback function to the listener.\n\n    Args:\n        callback (callable): The callback function to be added\n    \"\"\"\n    self.callbacks.append(callback)\n</code></pre>"},{"location":"reference/reactivity/#puepy.reactivity.Listener.notify","title":"<code>notify(*args, **kwargs)</code>","text":"<p>Notify method</p> <p>Executes each callback function in the callbacks list by passing in the given arguments and keyword arguments. If an exception occurs during the callback execution, it is logged using the logging library.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Variable length argument list.</p> <code>()</code> <code>**kwargs</code> <p>Arbitrary keyword arguments.</p> <code>{}</code> Source code in <code>puepy/reactivity.py</code> <pre><code>def notify(self, *args, **kwargs):\n    \"\"\"\n    Notify method\n\n    Executes each callback function in the callbacks list by passing in the given arguments and keyword arguments.\n    If an exception occurs during the callback execution, it is logged using the logging library.\n\n    Args:\n        *args: Variable length argument list.\n        **kwargs: Arbitrary keyword arguments.\n    \"\"\"\n    for callback in self.callbacks:\n        try:\n            callback(*args, **kwargs)\n        except Exception as e:\n            logging.exception(\"Error in callback for {self}: {callback}:\".format(self=self, callback=callback))\n</code></pre>"},{"location":"reference/reactivity/#puepy.reactivity.Listener.remove_callback","title":"<code>remove_callback(callback)</code>","text":"<p>Removes a callback function from the listener.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>callable</code> <p>The callback to be removed</p> required Source code in <code>puepy/reactivity.py</code> <pre><code>def remove_callback(self, callback):\n    \"\"\"\n    Removes a callback function from the listener.\n\n    Args:\n        callback (callable): The callback to be removed\n    \"\"\"\n    self.callbacks.remove(callback)\n</code></pre>"},{"location":"reference/reactivity/#puepy.reactivity.ReactiveDict","title":"<code>ReactiveDict</code>","text":"<p>               Bases: <code>dict</code></p> <p>A dictionary that notifies a listener when it is updated.</p> <p>Attributes:</p> Name Type Description <code>listener</code> <code>Listener</code> <p>A listener object that is notified when the dictionary is updated</p> <code>key_listeners</code> <code>dict</code> <p>A dictionary of listeners that are notified when a specific key is updated</p> Source code in <code>puepy/reactivity.py</code> <pre><code>class ReactiveDict(dict):\n    \"\"\"\n    A dictionary that notifies a listener when it is updated.\n\n    Attributes:\n        listener (Listener): A listener object that is notified when the dictionary is updated\n        key_listeners (dict): A dictionary of listeners that are notified when a specific key is updated\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args)\n        self.listener = Listener()\n        self.key_listeners = {}\n        self._in_mutation = False\n        self._notifications_pending = set()\n        self._keys_mutate = None\n\n    def add_key_listener(self, key, callback):\n        \"\"\"\n        Adds a key listener to the object.\n\n        Args:\n            key (str): The key for which the listener will be added.\n            callback (callable): The callback function to be executed when the key event is triggered.\n        \"\"\"\n        if key not in self.key_listeners:\n            self.key_listeners[key] = Listener()\n        self.key_listeners[key].add_callback(callback)\n\n    def notify(self, *keys):\n        \"\"\"\n        Notifies the listener and key listeners that the object has been updated.\n\n        Args:\n            *keys: A variable number of keys to be modified for key-specific listeners.\n        \"\"\"\n        if keys:\n            self._notifications_pending.update(keys)\n        else:\n            self._notifications_pending.update(self.keys())\n\n        if not self._in_mutation:\n            self._flush_pending()\n\n    def mutate(self, *keys):\n        \"\"\"\n        To be used as a context manager, this method is for either deferring all notifications until a change has been completed and/or notifying listeners when \"deep\" changes are made that would have gone undetected by `__setitem__`.\n\n        Examples:\n            ``` py\n            with reactive_dict.mutate(\"my_list\", \"my_dict\"):\n                reactive_dict[\"my_list\"].append(\"spam\")\n                reactive_dict[\"my_dict\"][\"spam\"] = \"eggs\"\n            ```\n\n        Args:\n            *keys: A variable number of keys to update the notifications pending attribute with. If no keys are provided, all keys in the object will be updated.\n\n        Returns:\n            The reactive dict itself, which stylistically could be nice to use in a `with` statement.\n        \"\"\"\n        if keys:\n            self._notifications_pending.update(keys)\n        else:\n            self._notifications_pending.update(self.keys())\n        self._keys_mutate = keys\n        return self\n\n    def update(self, other):\n        with self.mutate(*other.keys()):\n            super().update(other)\n\n    def _flush_pending(self):\n        while self._notifications_pending:\n            key = self._notifications_pending.pop()\n            value = self.get(key, None)\n            self.listener.notify(key, value)\n            if key in self.key_listeners:\n                self.key_listeners[key].notify(key, value)\n\n    def __setitem__(self, key, value):\n        if (key in self and value != self[key]) or key not in self:\n            super().__setitem__(key, value)\n            self.notify(key)\n\n    def __delitem__(self, key):\n        super().__delitem__(key)\n        self.notify(key)\n\n    def __enter__(self):\n        self._in_mutation = True\n\n        if len(self._keys_mutate) == 0:\n            return self.get(self._keys_mutate)\n        elif len(self._keys_mutate) &gt; 1:\n            return [self.get(k) for k in self._keys_mutate]\n\n    def __exit__(self, type, value, traceback):\n        self._in_mutation = False\n        self._flush_pending()\n</code></pre>"},{"location":"reference/reactivity/#puepy.reactivity.ReactiveDict.add_key_listener","title":"<code>add_key_listener(key, callback)</code>","text":"<p>Adds a key listener to the object.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key for which the listener will be added.</p> required <code>callback</code> <code>callable</code> <p>The callback function to be executed when the key event is triggered.</p> required Source code in <code>puepy/reactivity.py</code> <pre><code>def add_key_listener(self, key, callback):\n    \"\"\"\n    Adds a key listener to the object.\n\n    Args:\n        key (str): The key for which the listener will be added.\n        callback (callable): The callback function to be executed when the key event is triggered.\n    \"\"\"\n    if key not in self.key_listeners:\n        self.key_listeners[key] = Listener()\n    self.key_listeners[key].add_callback(callback)\n</code></pre>"},{"location":"reference/reactivity/#puepy.reactivity.ReactiveDict.mutate","title":"<code>mutate(*keys)</code>","text":"<p>To be used as a context manager, this method is for either deferring all notifications until a change has been completed and/or notifying listeners when \"deep\" changes are made that would have gone undetected by <code>__setitem__</code>.</p> <p>Examples:</p> <pre><code>with reactive_dict.mutate(\"my_list\", \"my_dict\"):\n    reactive_dict[\"my_list\"].append(\"spam\")\n    reactive_dict[\"my_dict\"][\"spam\"] = \"eggs\"\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>*keys</code> <p>A variable number of keys to update the notifications pending attribute with. If no keys are provided, all keys in the object will be updated.</p> <code>()</code> <p>Returns:</p> Type Description <p>The reactive dict itself, which stylistically could be nice to use in a <code>with</code> statement.</p> Source code in <code>puepy/reactivity.py</code> <pre><code>def mutate(self, *keys):\n    \"\"\"\n    To be used as a context manager, this method is for either deferring all notifications until a change has been completed and/or notifying listeners when \"deep\" changes are made that would have gone undetected by `__setitem__`.\n\n    Examples:\n        ``` py\n        with reactive_dict.mutate(\"my_list\", \"my_dict\"):\n            reactive_dict[\"my_list\"].append(\"spam\")\n            reactive_dict[\"my_dict\"][\"spam\"] = \"eggs\"\n        ```\n\n    Args:\n        *keys: A variable number of keys to update the notifications pending attribute with. If no keys are provided, all keys in the object will be updated.\n\n    Returns:\n        The reactive dict itself, which stylistically could be nice to use in a `with` statement.\n    \"\"\"\n    if keys:\n        self._notifications_pending.update(keys)\n    else:\n        self._notifications_pending.update(self.keys())\n    self._keys_mutate = keys\n    return self\n</code></pre>"},{"location":"reference/reactivity/#puepy.reactivity.ReactiveDict.notify","title":"<code>notify(*keys)</code>","text":"<p>Notifies the listener and key listeners that the object has been updated.</p> <p>Parameters:</p> Name Type Description Default <code>*keys</code> <p>A variable number of keys to be modified for key-specific listeners.</p> <code>()</code> Source code in <code>puepy/reactivity.py</code> <pre><code>def notify(self, *keys):\n    \"\"\"\n    Notifies the listener and key listeners that the object has been updated.\n\n    Args:\n        *keys: A variable number of keys to be modified for key-specific listeners.\n    \"\"\"\n    if keys:\n        self._notifications_pending.update(keys)\n    else:\n        self._notifications_pending.update(self.keys())\n\n    if not self._in_mutation:\n        self._flush_pending()\n</code></pre>"},{"location":"reference/reactivity/#puepy.reactivity.Stateful","title":"<code>Stateful</code>","text":"<p>A class that provides a reactive state management system for components. A</p> Source code in <code>puepy/reactivity.py</code> <pre><code>class Stateful:\n    \"\"\"\n    A class that provides a reactive state management system for components. A\n    \"\"\"\n\n    def add_context(self, name: str, value: ReactiveDict):\n        \"\"\"\n        Adds contxt from a reactive dict to be reacted on by the component.\n        \"\"\"\n        value.listener.add_callback(partial(self._on_state_change, name))\n\n    def initial(self):\n        \"\"\"\n        To be overridden in subclasses, the `initial()` method defines the initial state of the stateful object.\n\n        Returns:\n            (dict): Initial component state\n        \"\"\"\n        return {}\n\n    def on_state_change(self, context, key, value):\n        \"\"\"\n        To be overridden in subclasses, this method is called whenever the state of the component changes.\n\n        Args:\n            context: What context the state change occured in\n            key: The key modified\n            value: The new value\n        \"\"\"\n        pass\n\n    def _on_state_change(self, context, key, value):\n        self.on_state_change(context, key, value)\n\n        if hasattr(self, f\"on_{key}_change\"):\n            getattr(self, f\"on_{key}_change\")(value)\n</code></pre>"},{"location":"reference/reactivity/#puepy.reactivity.Stateful.add_context","title":"<code>add_context(name, value)</code>","text":"<p>Adds contxt from a reactive dict to be reacted on by the component.</p> Source code in <code>puepy/reactivity.py</code> <pre><code>def add_context(self, name: str, value: ReactiveDict):\n    \"\"\"\n    Adds contxt from a reactive dict to be reacted on by the component.\n    \"\"\"\n    value.listener.add_callback(partial(self._on_state_change, name))\n</code></pre>"},{"location":"reference/reactivity/#puepy.reactivity.Stateful.initial","title":"<code>initial()</code>","text":"<p>To be overridden in subclasses, the <code>initial()</code> method defines the initial state of the stateful object.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Initial component state</p> Source code in <code>puepy/reactivity.py</code> <pre><code>def initial(self):\n    \"\"\"\n    To be overridden in subclasses, the `initial()` method defines the initial state of the stateful object.\n\n    Returns:\n        (dict): Initial component state\n    \"\"\"\n    return {}\n</code></pre>"},{"location":"reference/reactivity/#puepy.reactivity.Stateful.on_state_change","title":"<code>on_state_change(context, key, value)</code>","text":"<p>To be overridden in subclasses, this method is called whenever the state of the component changes.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <p>What context the state change occured in</p> required <code>key</code> <p>The key modified</p> required <code>value</code> <p>The new value</p> required Source code in <code>puepy/reactivity.py</code> <pre><code>def on_state_change(self, context, key, value):\n    \"\"\"\n    To be overridden in subclasses, this method is called whenever the state of the component changes.\n\n    Args:\n        context: What context the state change occured in\n        key: The key modified\n        value: The new value\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/router/","title":"puepy.router","text":"<p>The <code>puepy.router</code> module contains code relevant to optional client-side routing in PuePy.</p> <p>See Also</p> <ul> <li>Tutorial: Routing</li> <li>Guide: Advanced Routing</li> </ul> <p>PuePy's router functionality can be optionally installed by calling the install_router method of the Application class.</p> Example <pre><code>from puepy import Application, Router\n\napp = Application()\napp.install_router(Router, link_mode=Router.LINK_MODE_HASH)\n</code></pre> <p>Once installed, the <code>Router</code> instance is available on <code>app.Router</code> and can be used throughout the application to manage client-side routing. Routes are defined by either using the <code>@app.page</code> decorator or by calling methods manually on the <code>Router</code> instance.</p> <p>Classes:</p> Name Description <code>puepy.router.Route</code> <p>Represents a route in the router.</p> <code>puepy.router.Router</code> <p>Represents a router for managing client-side routing in a web application.</p>"},{"location":"reference/router/#puepy.router.Route","title":"<code>Route</code>","text":"<p>Represents a route in the router. A route is defined by a path match pattern, a page class, and a name.</p> Note <p>This is usually not instanciated directly. Instead, use the <code>Router.add_route</code> method to create a new route or use the @app.page decorator to define a route at the time you define your Pages.</p> Source code in <code>puepy/router.py</code> <pre><code>class Route:\n    \"\"\"\n    Represents a route in the router. A route is defined by a path match pattern, a page class, and a name.\n\n    Note:\n        This is usually not instanciated directly. Instead, use the `Router.add_route` method to create a new route or\n        use the @app.page decorator to define a route at the time you define your Pages.\n    \"\"\"\n\n    def __init__(self, path_match: str, page: Page, name: str, base_path: str, router=None):\n        \"\"\"\n        Args:\n            path_match (str): The path match pattern used for routing.\n            page (Page): An instance of the Page class representing the page.\n            name (str): The name of the page.\n            base_path (str): The base path used for routing.\n            router (Router, optional): An optional parameter representing the router used for routing.\n        \"\"\"\n        self.path_match = path_match\n        self.page = page\n        self.name = name\n        self.base_path = base_path\n        self.router = router\n\n    def match(self, path):\n        \"\"\"\n        Evaluates a path against the route's pattern to determine if there is a match.\n\n        Args:\n            path: The path to be matched against the pattern.\n\n        Returns:\n            Match found (tuple): A tuple containing a True boolean value and a dictionary. The dictionary contains the\n            matched variables extracted from the path.\n\n            Match not found (tuple): If no match is found, returns `(False, None)`.\n        \"\"\"\n        if self.base_path and path.startswith(self.base_path):\n            path = path[len(self.base_path) :]\n\n        # Simple pattern matching without regex\n        parts = path.strip(\"/\").split(\"/\")\n        pattern_parts = self.path_match.strip(\"/\").split(\"/\")\n        if len(parts) != len(pattern_parts):\n            return False, None\n\n        kwargs = {}\n        for part, pattern_part in zip(parts, pattern_parts):\n            if pattern_part.startswith(\"&lt;\") and pattern_part.endswith(\"&gt;\"):\n                group_name = pattern_part[1:-1]\n                kwargs[group_name] = part\n            elif part != pattern_part:\n                return False, None\n\n        return True, kwargs\n\n    def reverse(self, **kwargs):\n        \"\"\"\n        Reverse method is used to generate a URL path using the given parameters. It replaces the placeholders in the\n        path template with the corresponding values.\n\n        Args:\n            **kwargs: A variable number of keyword arguments representing the values to be inserted into the path\n            template.\n\n        Returns:\n            (str): The generated URL path.\n\n        Example:\n            Let's say we have a path template `/users/&lt;username&gt;/posts/&lt;post_id&gt;`. We can use the reverse method to\n            generate the URL path by providing the values for \"username\" and \"post_id\" as keyword arguments:\n            `route.reverse(username=\"john\", post_id=123)` =&gt; `\"/users/john/posts/123\"`\n        \"\"\"\n        kwargs = kwargs.copy()\n        result = self.path_match\n        for key in list(kwargs.keys()):\n            if f\"&lt;{key}&gt;\" in result:\n                value = kwargs.pop(key)\n                result = result.replace(f\"&lt;{key}&gt;\", str(value))\n\n        if self.router and self.router.link_mode == Router.LINK_MODE_HASH:\n            result = \"#\" + result\n\n        if self.base_path:\n            path = f\"{self.base_path}{result}\"\n        else:\n            path = result\n\n        if kwargs:\n            path += \"?\" + \"&amp;\".join(f\"{url_quote(k)}={url_quote(v)}\" for k, v in kwargs.items())\n        return path\n\n    def __str__(self):\n        return self.name\n\n    def __repr__(self):\n        return f\"&lt;Route: {self.name}&gt;\"\n</code></pre>"},{"location":"reference/router/#puepy.router.Route.__init__","title":"<code>__init__(path_match, page, name, base_path, router=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>path_match</code> <code>str</code> <p>The path match pattern used for routing.</p> required <code>page</code> <code>Page</code> <p>An instance of the Page class representing the page.</p> required <code>name</code> <code>str</code> <p>The name of the page.</p> required <code>base_path</code> <code>str</code> <p>The base path used for routing.</p> required <code>router</code> <code>Router</code> <p>An optional parameter representing the router used for routing.</p> <code>None</code> Source code in <code>puepy/router.py</code> <pre><code>def __init__(self, path_match: str, page: Page, name: str, base_path: str, router=None):\n    \"\"\"\n    Args:\n        path_match (str): The path match pattern used for routing.\n        page (Page): An instance of the Page class representing the page.\n        name (str): The name of the page.\n        base_path (str): The base path used for routing.\n        router (Router, optional): An optional parameter representing the router used for routing.\n    \"\"\"\n    self.path_match = path_match\n    self.page = page\n    self.name = name\n    self.base_path = base_path\n    self.router = router\n</code></pre>"},{"location":"reference/router/#puepy.router.Route.match","title":"<code>match(path)</code>","text":"<p>Evaluates a path against the route's pattern to determine if there is a match.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <p>The path to be matched against the pattern.</p> required <p>Returns:</p> Type Description <p>Match found (tuple): A tuple containing a True boolean value and a dictionary. The dictionary contains the</p> <p>matched variables extracted from the path.</p> <p>Match not found (tuple): If no match is found, returns <code>(False, None)</code>.</p> Source code in <code>puepy/router.py</code> <pre><code>def match(self, path):\n    \"\"\"\n    Evaluates a path against the route's pattern to determine if there is a match.\n\n    Args:\n        path: The path to be matched against the pattern.\n\n    Returns:\n        Match found (tuple): A tuple containing a True boolean value and a dictionary. The dictionary contains the\n        matched variables extracted from the path.\n\n        Match not found (tuple): If no match is found, returns `(False, None)`.\n    \"\"\"\n    if self.base_path and path.startswith(self.base_path):\n        path = path[len(self.base_path) :]\n\n    # Simple pattern matching without regex\n    parts = path.strip(\"/\").split(\"/\")\n    pattern_parts = self.path_match.strip(\"/\").split(\"/\")\n    if len(parts) != len(pattern_parts):\n        return False, None\n\n    kwargs = {}\n    for part, pattern_part in zip(parts, pattern_parts):\n        if pattern_part.startswith(\"&lt;\") and pattern_part.endswith(\"&gt;\"):\n            group_name = pattern_part[1:-1]\n            kwargs[group_name] = part\n        elif part != pattern_part:\n            return False, None\n\n    return True, kwargs\n</code></pre>"},{"location":"reference/router/#puepy.router.Route.reverse","title":"<code>reverse(**kwargs)</code>","text":"<p>Reverse method is used to generate a URL path using the given parameters. It replaces the placeholders in the path template with the corresponding values.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>A variable number of keyword arguments representing the values to be inserted into the path</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The generated URL path.</p> Example <p>Let's say we have a path template <code>/users/&lt;username&gt;/posts/&lt;post_id&gt;</code>. We can use the reverse method to generate the URL path by providing the values for \"username\" and \"post_id\" as keyword arguments: <code>route.reverse(username=\"john\", post_id=123)</code> =&gt; <code>\"/users/john/posts/123\"</code></p> Source code in <code>puepy/router.py</code> <pre><code>def reverse(self, **kwargs):\n    \"\"\"\n    Reverse method is used to generate a URL path using the given parameters. It replaces the placeholders in the\n    path template with the corresponding values.\n\n    Args:\n        **kwargs: A variable number of keyword arguments representing the values to be inserted into the path\n        template.\n\n    Returns:\n        (str): The generated URL path.\n\n    Example:\n        Let's say we have a path template `/users/&lt;username&gt;/posts/&lt;post_id&gt;`. We can use the reverse method to\n        generate the URL path by providing the values for \"username\" and \"post_id\" as keyword arguments:\n        `route.reverse(username=\"john\", post_id=123)` =&gt; `\"/users/john/posts/123\"`\n    \"\"\"\n    kwargs = kwargs.copy()\n    result = self.path_match\n    for key in list(kwargs.keys()):\n        if f\"&lt;{key}&gt;\" in result:\n            value = kwargs.pop(key)\n            result = result.replace(f\"&lt;{key}&gt;\", str(value))\n\n    if self.router and self.router.link_mode == Router.LINK_MODE_HASH:\n        result = \"#\" + result\n\n    if self.base_path:\n        path = f\"{self.base_path}{result}\"\n    else:\n        path = result\n\n    if kwargs:\n        path += \"?\" + \"&amp;\".join(f\"{url_quote(k)}={url_quote(v)}\" for k, v in kwargs.items())\n    return path\n</code></pre>"},{"location":"reference/router/#puepy.router.Router","title":"<code>Router</code>","text":"<p>Class representing a router for managing client-side routing in a web application.</p> <p>Parameters:</p> Name Type Description Default <code>application</code> <code>object</code> <p>The web application object. Defaults to None.</p> <code>None</code> <code>base_path</code> <code>str</code> <p>The base path URL. Defaults to None.</p> <code>None</code> <code>link_mode</code> <code>str</code> <p>The link mode for navigating. Defaults to \"hash\".</p> <code>LINK_MODE_HASH</code> <p>Attributes:</p> Name Type Description <code>LINK_MODE_DIRECT</code> <code>str</code> <p>Direct link mode.</p> <code>LINK_MODE_HTML5</code> <code>str</code> <p>HTML5 link mode.</p> <code>LINK_MODE_HASH</code> <code>str</code> <p>Hash link mode.</p> <code>routes</code> <code>list</code> <p>List of Route instances.</p> <code>routes_by_name</code> <code>dict</code> <p>Dictionary mapping route names to Route instances.</p> <code>routes_by_page</code> <code>dict</code> <p>Dictionary mapping page classes to Route instances.</p> <code>application</code> <code>object</code> <p>The web application object.</p> <code>base_path</code> <code>str</code> <p>The base path URL.</p> <code>link_mode</code> <code>str</code> <p>The link mode for navigating.</p> Source code in <code>puepy/router.py</code> <pre><code>class Router:\n    \"\"\"Class representing a router for managing client-side routing in a web application.\n\n\n\n    Args:\n        application (object, optional): The web application object. Defaults to None.\n        base_path (str, optional): The base path URL. Defaults to None.\n        link_mode (str, optional): The link mode for navigating. Defaults to \"hash\".\n\n    Attributes:\n        LINK_MODE_DIRECT (str): Direct link mode.\n        LINK_MODE_HTML5 (str): HTML5 link mode.\n        LINK_MODE_HASH (str): Hash link mode.\n        routes (list): List of Route instances.\n        routes_by_name (dict): Dictionary mapping route names to Route instances.\n        routes_by_page (dict): Dictionary mapping page classes to Route instances.\n        application (object): The web application object.\n        base_path (str): The base path URL.\n        link_mode (str): The link mode for navigating.\n    \"\"\"\n\n    LINK_MODE_DIRECT = \"direct\"\n    LINK_MODE_HTML5 = \"html5\"\n    LINK_MODE_HASH = \"hash\"\n\n    def __init__(self, application=None, base_path=None, link_mode=LINK_MODE_HASH):\n        \"\"\"\n        Initializes an instance of the class.\n\n        Parameters:\n            application (Application): The application used for routing.\n            base_path (str): The base path for the routes.\n            link_mode (str): The mode for generating links.\n        \"\"\"\n        self.routes = []\n        self.routes_by_name = {}\n        self.routes_by_page = {}\n        self.application = application\n        self.base_path = base_path\n        self.link_mode = link_mode\n\n    def add_route_instance(self, route: Route):\n        \"\"\"\n        Add a route instance to the current router.\n\n        Parameters:\n            route (Route): The route instance to be added.\n\n        Raises:\n            ValueError: If the route instance or route name already exists in the router.\n        \"\"\"\n        if route in self.routes:\n            raise ValueError(f\"Route already added: {route}\")\n        if route.name in self.routes_by_name:\n            raise ValueError(f\"Route name already exists for another route: {route.name}\")\n        self.routes.append(route)\n        self.routes_by_name[route.name] = route\n        self.routes_by_page[route.page] = route\n        route.router = self\n\n    def add_route(self, path_match, page_class, name=None):\n        \"\"\"\n        Adds a route to the router. This method creates a new Route instance.\n\n        Args:\n            path_match (str): The URL path pattern to match for the route.\n            page_class (Page class): The class or function to be associated with the route.\n            name (str, optional): The name of the route. If not provided, the name will be derived from the page class name.\n        \"\"\"\n        # Convert path to a simple pattern without regex\n        if not name:\n            name = mixed_to_underscores(page_class.__name__)\n        self.add_route_instance(Route(path_match=path_match, page=page_class, name=name, base_path=self.base_path))\n\n    def reverse(self, destination, **kwargs):\n        \"\"\"\n        Reverses a\n\n        Args:\n            destination: The destination to reverse. It can be the name of a route, the mapped page of a route, or the default page of the application.\n            **kwargs: Additional keyword arguments to be passed to the reverse method of the destination route.\n\n        Returns:\n            (str): The reversed URL for the given destination.\n\n        Raises:\n            KeyError: If the destination is not found in the routes.\n        \"\"\"\n        route: Route\n        if isinstance(destination, Route):\n            return destination.reverse(**kwargs)\n        elif destination in self.routes_by_name:\n            route = self.routes_by_name[destination]\n        elif destination in self.routes_by_page:\n            route = self.routes_by_page[destination]\n        elif self.application and destination is self.application.default_page:\n            if self.link_mode == Router.LINK_MODE_HASH:\n                path = \"#/\"\n            else:\n                path = \"/\"\n            return self.base_path or \"\" + path\n        else:\n            raise KeyError(f\"{destination} not found in routes\")\n        return route.reverse(**kwargs)\n\n    def match(self, path):\n        \"\"\"\n        Args:\n            path (str): The path to be matched.\n\n        Returns:\n            (tuple): A tuple containing the matching route and the matched route arguments (if any). If no route is\n                found, returns (None, None).\n        \"\"\"\n        path = path.split(\"#\")[0]\n        if \"?\" not in path:\n            path += \"?\"\n        path, query_string = path.split(\"?\", 1)\n        arguments = parse_query_string(query_string)\n\n        for route in self.routes:\n            matches, path_arguments = route.match(path)\n            if path_arguments:\n                arguments.update(path_arguments)\n            if matches:\n                return route, arguments\n        return None, None\n\n    def navigate_to_path(self, path, **kwargs):\n        \"\"\"\n        Navigates to the specified path.\n\n        Args:\n            path (str or Page): The path to navigate to. If path is a subclass of Page, it will be reversed using the reverse method\n            provided by the self object. If path is a string and **kwargs is not empty, it will append the query string\n            to the path.\n\n            **kwargs: Additional key-value pairs to be included in the query string. Each key-value pair will be\n            URL-encoded.\n\n        Raises:\n            Exception: If the link mode is invalid.\n        \"\"\"\n        if isinstance(path, type) and issubclass(path, Page):\n            path = self.reverse(path, **kwargs)\n        elif kwargs:\n            path += \"?\" + \"&amp;\".join(f\"{url_quote(k)}={url_quote(v)}\" for k, v in kwargs.items())\n\n        if self.link_mode == self.LINK_MODE_DIRECT:\n            window.location = path\n        elif self.link_mode == self.LINK_MODE_HTML5:\n            history.pushState(jsobj(), \"\", path)\n            self.application.mount(self.application._selector_or_element, path)\n        elif self.link_mode == self.LINK_MODE_HASH:\n            path = path[1:] if path.startswith(\"#\") else path\n            if not is_server_side:\n                history.pushState(jsobj(), \"\", \"#\" + path)\n            self.application.mount(self.application._selector_or_element, path)\n        else:\n            raise Exception(f\"Invalid link mode: {self.link_mode}\")\n</code></pre>"},{"location":"reference/router/#puepy.router.Router.__init__","title":"<code>__init__(application=None, base_path=None, link_mode=LINK_MODE_HASH)</code>","text":"<p>Initializes an instance of the class.</p> <p>Parameters:</p> Name Type Description Default <code>application</code> <code>Application</code> <p>The application used for routing.</p> <code>None</code> <code>base_path</code> <code>str</code> <p>The base path for the routes.</p> <code>None</code> <code>link_mode</code> <code>str</code> <p>The mode for generating links.</p> <code>LINK_MODE_HASH</code> Source code in <code>puepy/router.py</code> <pre><code>def __init__(self, application=None, base_path=None, link_mode=LINK_MODE_HASH):\n    \"\"\"\n    Initializes an instance of the class.\n\n    Parameters:\n        application (Application): The application used for routing.\n        base_path (str): The base path for the routes.\n        link_mode (str): The mode for generating links.\n    \"\"\"\n    self.routes = []\n    self.routes_by_name = {}\n    self.routes_by_page = {}\n    self.application = application\n    self.base_path = base_path\n    self.link_mode = link_mode\n</code></pre>"},{"location":"reference/router/#puepy.router.Router.add_route","title":"<code>add_route(path_match, page_class, name=None)</code>","text":"<p>Adds a route to the router. This method creates a new Route instance.</p> <p>Parameters:</p> Name Type Description Default <code>path_match</code> <code>str</code> <p>The URL path pattern to match for the route.</p> required <code>page_class</code> <code>Page class</code> <p>The class or function to be associated with the route.</p> required <code>name</code> <code>str</code> <p>The name of the route. If not provided, the name will be derived from the page class name.</p> <code>None</code> Source code in <code>puepy/router.py</code> <pre><code>def add_route(self, path_match, page_class, name=None):\n    \"\"\"\n    Adds a route to the router. This method creates a new Route instance.\n\n    Args:\n        path_match (str): The URL path pattern to match for the route.\n        page_class (Page class): The class or function to be associated with the route.\n        name (str, optional): The name of the route. If not provided, the name will be derived from the page class name.\n    \"\"\"\n    # Convert path to a simple pattern without regex\n    if not name:\n        name = mixed_to_underscores(page_class.__name__)\n    self.add_route_instance(Route(path_match=path_match, page=page_class, name=name, base_path=self.base_path))\n</code></pre>"},{"location":"reference/router/#puepy.router.Router.add_route_instance","title":"<code>add_route_instance(route)</code>","text":"<p>Add a route instance to the current router.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>Route</code> <p>The route instance to be added.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the route instance or route name already exists in the router.</p> Source code in <code>puepy/router.py</code> <pre><code>def add_route_instance(self, route: Route):\n    \"\"\"\n    Add a route instance to the current router.\n\n    Parameters:\n        route (Route): The route instance to be added.\n\n    Raises:\n        ValueError: If the route instance or route name already exists in the router.\n    \"\"\"\n    if route in self.routes:\n        raise ValueError(f\"Route already added: {route}\")\n    if route.name in self.routes_by_name:\n        raise ValueError(f\"Route name already exists for another route: {route.name}\")\n    self.routes.append(route)\n    self.routes_by_name[route.name] = route\n    self.routes_by_page[route.page] = route\n    route.router = self\n</code></pre>"},{"location":"reference/router/#puepy.router.Router.match","title":"<code>match(path)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to be matched.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the matching route and the matched route arguments (if any). If no route is found, returns (None, None).</p> Source code in <code>puepy/router.py</code> <pre><code>def match(self, path):\n    \"\"\"\n    Args:\n        path (str): The path to be matched.\n\n    Returns:\n        (tuple): A tuple containing the matching route and the matched route arguments (if any). If no route is\n            found, returns (None, None).\n    \"\"\"\n    path = path.split(\"#\")[0]\n    if \"?\" not in path:\n        path += \"?\"\n    path, query_string = path.split(\"?\", 1)\n    arguments = parse_query_string(query_string)\n\n    for route in self.routes:\n        matches, path_arguments = route.match(path)\n        if path_arguments:\n            arguments.update(path_arguments)\n        if matches:\n            return route, arguments\n    return None, None\n</code></pre>"},{"location":"reference/router/#puepy.router.Router.navigate_to_path","title":"<code>navigate_to_path(path, **kwargs)</code>","text":"<p>Navigates to the specified path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or Page</code> <p>The path to navigate to. If path is a subclass of Page, it will be reversed using the reverse method</p> required <code>**kwargs</code> <p>Additional key-value pairs to be included in the query string. Each key-value pair will be</p> <code>{}</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If the link mode is invalid.</p> Source code in <code>puepy/router.py</code> <pre><code>def navigate_to_path(self, path, **kwargs):\n    \"\"\"\n    Navigates to the specified path.\n\n    Args:\n        path (str or Page): The path to navigate to. If path is a subclass of Page, it will be reversed using the reverse method\n        provided by the self object. If path is a string and **kwargs is not empty, it will append the query string\n        to the path.\n\n        **kwargs: Additional key-value pairs to be included in the query string. Each key-value pair will be\n        URL-encoded.\n\n    Raises:\n        Exception: If the link mode is invalid.\n    \"\"\"\n    if isinstance(path, type) and issubclass(path, Page):\n        path = self.reverse(path, **kwargs)\n    elif kwargs:\n        path += \"?\" + \"&amp;\".join(f\"{url_quote(k)}={url_quote(v)}\" for k, v in kwargs.items())\n\n    if self.link_mode == self.LINK_MODE_DIRECT:\n        window.location = path\n    elif self.link_mode == self.LINK_MODE_HTML5:\n        history.pushState(jsobj(), \"\", path)\n        self.application.mount(self.application._selector_or_element, path)\n    elif self.link_mode == self.LINK_MODE_HASH:\n        path = path[1:] if path.startswith(\"#\") else path\n        if not is_server_side:\n            history.pushState(jsobj(), \"\", \"#\" + path)\n        self.application.mount(self.application._selector_or_element, path)\n    else:\n        raise Exception(f\"Invalid link mode: {self.link_mode}\")\n</code></pre>"},{"location":"reference/router/#puepy.router.Router.reverse","title":"<code>reverse(destination, **kwargs)</code>","text":"<p>Reverses a</p> <p>Parameters:</p> Name Type Description Default <code>destination</code> <p>The destination to reverse. It can be the name of a route, the mapped page of a route, or the default page of the application.</p> required <code>**kwargs</code> <p>Additional keyword arguments to be passed to the reverse method of the destination route.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The reversed URL for the given destination.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the destination is not found in the routes.</p> Source code in <code>puepy/router.py</code> <pre><code>def reverse(self, destination, **kwargs):\n    \"\"\"\n    Reverses a\n\n    Args:\n        destination: The destination to reverse. It can be the name of a route, the mapped page of a route, or the default page of the application.\n        **kwargs: Additional keyword arguments to be passed to the reverse method of the destination route.\n\n    Returns:\n        (str): The reversed URL for the given destination.\n\n    Raises:\n        KeyError: If the destination is not found in the routes.\n    \"\"\"\n    route: Route\n    if isinstance(destination, Route):\n        return destination.reverse(**kwargs)\n    elif destination in self.routes_by_name:\n        route = self.routes_by_name[destination]\n    elif destination in self.routes_by_page:\n        route = self.routes_by_page[destination]\n    elif self.application and destination is self.application.default_page:\n        if self.link_mode == Router.LINK_MODE_HASH:\n            path = \"#/\"\n        else:\n            path = \"/\"\n        return self.base_path or \"\" + path\n    else:\n        raise KeyError(f\"{destination} not found in routes\")\n    return route.reverse(**kwargs)\n</code></pre>"},{"location":"reference/router/#puepy.router._micropython_parse_query_string","title":"<code>_micropython_parse_query_string(query_string)</code>","text":"<p>In MicroPython, urllib isn't available and we can't use the JavaScript library: https://github.com/pyscript/pyscript/issues/2100</p> Source code in <code>puepy/router.py</code> <pre><code>def _micropython_parse_query_string(query_string):\n    \"\"\"\n    In MicroPython, urllib isn't available and we can't use the JavaScript library:\n    https://github.com/pyscript/pyscript/issues/2100\n    \"\"\"\n    if query_string and query_string[0] == \"?\":\n        query_string = query_string[1:]\n\n    def url_decode(s):\n        # Decode URL-encoded characters without using regex, which is also pretty broken in MicroPython...\n        i = 0\n        length = len(s)\n        decoded = []\n\n        while i &lt; length:\n            if s[i] == \"%\":\n                if i + 2 &lt; length:\n                    hex_value = s[i + 1 : i + 3]\n                    decoded.append(chr(int(hex_value, 16)))\n                    i += 3\n                else:\n                    decoded.append(\"%\")\n                    i += 1\n            elif s[i] == \"+\":\n                decoded.append(\" \")\n                i += 1\n            else:\n                decoded.append(s[i])\n                i += 1\n\n        return \"\".join(decoded)\n\n    params = {}\n    for part in query_string.split(\"&amp;\"):\n        if \"=\" in part:\n            key, value = part.split(\"=\", 1)\n            key = url_decode(key)\n            value = url_decode(value)\n            if key in params:\n                params[key].append(value)\n            else:\n                params[key] = [value]\n        else:\n            key = url_decode(part)\n            if key in params:\n                params[key].append(\"\")\n            else:\n                params[key] = \"\"\n    return params\n</code></pre>"},{"location":"reference/storage/","title":"puepy.storage","text":""},{"location":"reference/storage/#puepystorage","title":"puepy.storage","text":"<p>Browser Storage Module</p> <p>This module provides a <code>BrowserStorage</code> class that interfaces with browser storage objects such as <code>localStorage</code> and <code>sessionStorage</code>. It mimics dictionary-like behavior for interacting with storage items.</p> <p>Classes:</p> Name Description <code>BrowserStorage</code> <p>A class that provides dictionary-like access to browser storage objects.</p>"},{"location":"reference/storage/#puepy.storage.BrowserStorage","title":"<code>BrowserStorage</code>","text":"<p>Provides dictionary-like interface to browser storage objects.</p> <p>Attributes:</p> Name Type Description <code>target</code> <p>The browser storage object (e.g., localStorage, sessionStorage).</p> <code>description</code> <code>str</code> <p>Description of the storage instance.</p> Source code in <code>puepy/storage.py</code> <pre><code>class BrowserStorage:\n    \"\"\"\n    Provides dictionary-like interface to browser storage objects.\n\n    Attributes:\n        target: The browser storage object (e.g., localStorage, sessionStorage).\n        description (str): Description of the storage instance.\n\n    \"\"\"\n\n    class NoDefault:\n        \"\"\"Placeholder class for default values when no default is provided.\"\"\"\n\n        pass\n\n    def __init__(self, target, description):\n        \"\"\"\n        Initializes the BrowserStorage instance.\n\n        Args:\n            target: The browser storage object.\n            description (str): Description of the storage instance.\n        \"\"\"\n        self.target = target\n        self.description = description\n\n    def __getitem__(self, key):\n        \"\"\"\n        Retrieves the value for a given key from the storage.\n\n        Args:\n            key (str): The key for the item to retrieve.\n\n        Returns:\n            The value associated with the key.\n\n        Raises:\n            KeyError: If the key does not exist in the storage.\n        \"\"\"\n        value = self.target.getItem(key)\n        if value is None:\n            raise KeyError(key)\n        return value\n\n    def __setitem__(self, key, value):\n        \"\"\"\n        Sets the value for a given key in the storage.\n\n        Args:\n            key (str): The key for the item to set.\n            value: The value to associate with the key.\n        \"\"\"\n        self.target.setItem(key, str(value))\n\n    def __delitem__(self, key):\n        \"\"\"\n        Deletes the item for a given key from the storage.\n\n        Args:\n            key (str): The key for the item to delete.\n\n        Raises:\n            KeyError: If the key does not exist in the storage.\n        \"\"\"\n        if self.target.getItem(key) is None:\n            raise KeyError(key)\n        self.target.removeItem(key)\n\n    def __contains__(self, key):\n        \"\"\"\n        Checks if a key exists in the storage.\n\n        Args:\n            key (str): The key to check.\n\n        Returns:\n            bool: True if the key exists, False otherwise.\n        \"\"\"\n        return not self.target.getItem(key) is None\n\n    def __len__(self):\n        \"\"\"\n        Returns the number of items in the storage.\n\n        Returns:\n            int: The number of items in the storage.\n        \"\"\"\n        return self.target.length\n\n    def __iter__(self):\n        \"\"\"\n        Returns an iterator over the keys in the storage.\n\n        Returns:\n            iterator: An iterator over the keys.\n        \"\"\"\n        return iter(self.keys())\n\n    def items(self):\n        \"\"\"\n        Returns an iterator over the (key, value) pairs in the storage.\n\n        Yields:\n            tuple: (key, value) pairs in the storage.\n        \"\"\"\n        for item in Object.entries(self.target):\n            yield item[0], item[1]\n\n    def keys(self):\n        \"\"\"\n        Returns a list of keys in the storage.\n\n        Returns:\n            list: A list of keys.\n        \"\"\"\n        return list(Object.keys(self.target))\n\n    def get(self, key, default=None):\n        \"\"\"\n        Retrieves the value for a given key, returning a default value if the key does not exist.\n\n        Args:\n            key (str): The key for the item to retrieve.\n            default: The default value to return if the key does not exist.\n\n        Returns:\n            The value associated with the key, or the default value.\n        \"\"\"\n        value = self.target.getItem(key)\n        if value is None:\n            return default\n        else:\n            return value\n\n    def clear(self):\n        \"\"\"\n        Clears all items from the storage.\n        \"\"\"\n        self.target.clear()\n\n    def copy(self):\n        \"\"\"\n        Returns a copy of the storage as a dictionary.\n\n        Returns:\n            dict: A dictionary containing all items in the storage.\n        \"\"\"\n        return dict(self.items())\n\n    def pop(self, key, default=NoDefault):\n        \"\"\"\n        Removes the item with the given key from the storage and returns its value.\n\n        Args:\n            key (str): The key for the item to remove.\n            default: The default value to return if the key does not exist.\n\n        Returns:\n            The value associated with the key, or the default value.\n\n        Raises:\n            KeyError: If the key does not exist and no default value is provided.\n        \"\"\"\n        value = self.target.getItem(key)\n        if value is None and default is self.NoDefault:\n            raise KeyError(key)\n        else:\n            self.target.removeItem(key)\n            return value\n\n    def popitem(self):\n        \"\"\"\n        Not implemented. Raises NotImplementedError.\n\n        Raises:\n            NotImplementedError: Always raised as the method is not implemented.\n        \"\"\"\n        raise NotImplementedError(\"popitem not implemented\")\n\n    def reversed(self):\n        \"\"\"\n        Not implemented. Raises NotImplementedError.\n\n        Raises:\n            NotImplementedError: Always raised as the method is not implemented.\n        \"\"\"\n        raise NotImplementedError(\"reversed not implemented\")\n\n    def setdefault(self, key, default=None):\n        \"\"\"\n        Sets the value for the key if it does not already exist in the storage.\n\n        Args:\n            key (str): The key for the item.\n            default: The value to set if the key does not exist.\n\n        Returns:\n            The value associated with the key, or the default value.\n        \"\"\"\n        if key in self:\n            return self[key]\n        else:\n            self[key] = default\n            return default\n\n    def update(self, other):\n        \"\"\"\n        Updates the storage with items from another dictionary or iterable of key-value pairs.\n\n        Args:\n            other: A dictionary or iterable of key-value pairs to update the storage with.\n        \"\"\"\n        for k, v in other.items():\n            self[k] = v\n\n    def values(self):\n        \"\"\"\n        Returns a list of values in the storage.\n\n        Returns:\n            list: A list of values.\n        \"\"\"\n        return list(Object.values(self.target))\n\n    def __str__(self):\n        return self.description\n\n    def __repr__(self):\n        return f\"&lt;{self}&gt;\"\n</code></pre>"},{"location":"reference/storage/#puepy.storage.BrowserStorage.NoDefault","title":"<code>NoDefault</code>","text":"<p>Placeholder class for default values when no default is provided.</p> Source code in <code>puepy/storage.py</code> <pre><code>class NoDefault:\n    \"\"\"Placeholder class for default values when no default is provided.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/storage/#puepy.storage.BrowserStorage.__contains__","title":"<code>__contains__(key)</code>","text":"<p>Checks if a key exists in the storage.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the key exists, False otherwise.</p> Source code in <code>puepy/storage.py</code> <pre><code>def __contains__(self, key):\n    \"\"\"\n    Checks if a key exists in the storage.\n\n    Args:\n        key (str): The key to check.\n\n    Returns:\n        bool: True if the key exists, False otherwise.\n    \"\"\"\n    return not self.target.getItem(key) is None\n</code></pre>"},{"location":"reference/storage/#puepy.storage.BrowserStorage.__delitem__","title":"<code>__delitem__(key)</code>","text":"<p>Deletes the item for a given key from the storage.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key for the item to delete.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key does not exist in the storage.</p> Source code in <code>puepy/storage.py</code> <pre><code>def __delitem__(self, key):\n    \"\"\"\n    Deletes the item for a given key from the storage.\n\n    Args:\n        key (str): The key for the item to delete.\n\n    Raises:\n        KeyError: If the key does not exist in the storage.\n    \"\"\"\n    if self.target.getItem(key) is None:\n        raise KeyError(key)\n    self.target.removeItem(key)\n</code></pre>"},{"location":"reference/storage/#puepy.storage.BrowserStorage.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Retrieves the value for a given key from the storage.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key for the item to retrieve.</p> required <p>Returns:</p> Type Description <p>The value associated with the key.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key does not exist in the storage.</p> Source code in <code>puepy/storage.py</code> <pre><code>def __getitem__(self, key):\n    \"\"\"\n    Retrieves the value for a given key from the storage.\n\n    Args:\n        key (str): The key for the item to retrieve.\n\n    Returns:\n        The value associated with the key.\n\n    Raises:\n        KeyError: If the key does not exist in the storage.\n    \"\"\"\n    value = self.target.getItem(key)\n    if value is None:\n        raise KeyError(key)\n    return value\n</code></pre>"},{"location":"reference/storage/#puepy.storage.BrowserStorage.__init__","title":"<code>__init__(target, description)</code>","text":"<p>Initializes the BrowserStorage instance.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <p>The browser storage object.</p> required <code>description</code> <code>str</code> <p>Description of the storage instance.</p> required Source code in <code>puepy/storage.py</code> <pre><code>def __init__(self, target, description):\n    \"\"\"\n    Initializes the BrowserStorage instance.\n\n    Args:\n        target: The browser storage object.\n        description (str): Description of the storage instance.\n    \"\"\"\n    self.target = target\n    self.description = description\n</code></pre>"},{"location":"reference/storage/#puepy.storage.BrowserStorage.__iter__","title":"<code>__iter__()</code>","text":"<p>Returns an iterator over the keys in the storage.</p> <p>Returns:</p> Name Type Description <code>iterator</code> <p>An iterator over the keys.</p> Source code in <code>puepy/storage.py</code> <pre><code>def __iter__(self):\n    \"\"\"\n    Returns an iterator over the keys in the storage.\n\n    Returns:\n        iterator: An iterator over the keys.\n    \"\"\"\n    return iter(self.keys())\n</code></pre>"},{"location":"reference/storage/#puepy.storage.BrowserStorage.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of items in the storage.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The number of items in the storage.</p> Source code in <code>puepy/storage.py</code> <pre><code>def __len__(self):\n    \"\"\"\n    Returns the number of items in the storage.\n\n    Returns:\n        int: The number of items in the storage.\n    \"\"\"\n    return self.target.length\n</code></pre>"},{"location":"reference/storage/#puepy.storage.BrowserStorage.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Sets the value for a given key in the storage.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key for the item to set.</p> required <code>value</code> <p>The value to associate with the key.</p> required Source code in <code>puepy/storage.py</code> <pre><code>def __setitem__(self, key, value):\n    \"\"\"\n    Sets the value for a given key in the storage.\n\n    Args:\n        key (str): The key for the item to set.\n        value: The value to associate with the key.\n    \"\"\"\n    self.target.setItem(key, str(value))\n</code></pre>"},{"location":"reference/storage/#puepy.storage.BrowserStorage.clear","title":"<code>clear()</code>","text":"<p>Clears all items from the storage.</p> Source code in <code>puepy/storage.py</code> <pre><code>def clear(self):\n    \"\"\"\n    Clears all items from the storage.\n    \"\"\"\n    self.target.clear()\n</code></pre>"},{"location":"reference/storage/#puepy.storage.BrowserStorage.copy","title":"<code>copy()</code>","text":"<p>Returns a copy of the storage as a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing all items in the storage.</p> Source code in <code>puepy/storage.py</code> <pre><code>def copy(self):\n    \"\"\"\n    Returns a copy of the storage as a dictionary.\n\n    Returns:\n        dict: A dictionary containing all items in the storage.\n    \"\"\"\n    return dict(self.items())\n</code></pre>"},{"location":"reference/storage/#puepy.storage.BrowserStorage.get","title":"<code>get(key, default=None)</code>","text":"<p>Retrieves the value for a given key, returning a default value if the key does not exist.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key for the item to retrieve.</p> required <code>default</code> <p>The default value to return if the key does not exist.</p> <code>None</code> <p>Returns:</p> Type Description <p>The value associated with the key, or the default value.</p> Source code in <code>puepy/storage.py</code> <pre><code>def get(self, key, default=None):\n    \"\"\"\n    Retrieves the value for a given key, returning a default value if the key does not exist.\n\n    Args:\n        key (str): The key for the item to retrieve.\n        default: The default value to return if the key does not exist.\n\n    Returns:\n        The value associated with the key, or the default value.\n    \"\"\"\n    value = self.target.getItem(key)\n    if value is None:\n        return default\n    else:\n        return value\n</code></pre>"},{"location":"reference/storage/#puepy.storage.BrowserStorage.items","title":"<code>items()</code>","text":"<p>Returns an iterator over the (key, value) pairs in the storage.</p> <p>Yields:</p> Name Type Description <code>tuple</code> <p>(key, value) pairs in the storage.</p> Source code in <code>puepy/storage.py</code> <pre><code>def items(self):\n    \"\"\"\n    Returns an iterator over the (key, value) pairs in the storage.\n\n    Yields:\n        tuple: (key, value) pairs in the storage.\n    \"\"\"\n    for item in Object.entries(self.target):\n        yield item[0], item[1]\n</code></pre>"},{"location":"reference/storage/#puepy.storage.BrowserStorage.keys","title":"<code>keys()</code>","text":"<p>Returns a list of keys in the storage.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of keys.</p> Source code in <code>puepy/storage.py</code> <pre><code>def keys(self):\n    \"\"\"\n    Returns a list of keys in the storage.\n\n    Returns:\n        list: A list of keys.\n    \"\"\"\n    return list(Object.keys(self.target))\n</code></pre>"},{"location":"reference/storage/#puepy.storage.BrowserStorage.pop","title":"<code>pop(key, default=NoDefault)</code>","text":"<p>Removes the item with the given key from the storage and returns its value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key for the item to remove.</p> required <code>default</code> <p>The default value to return if the key does not exist.</p> <code>NoDefault</code> <p>Returns:</p> Type Description <p>The value associated with the key, or the default value.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key does not exist and no default value is provided.</p> Source code in <code>puepy/storage.py</code> <pre><code>def pop(self, key, default=NoDefault):\n    \"\"\"\n    Removes the item with the given key from the storage and returns its value.\n\n    Args:\n        key (str): The key for the item to remove.\n        default: The default value to return if the key does not exist.\n\n    Returns:\n        The value associated with the key, or the default value.\n\n    Raises:\n        KeyError: If the key does not exist and no default value is provided.\n    \"\"\"\n    value = self.target.getItem(key)\n    if value is None and default is self.NoDefault:\n        raise KeyError(key)\n    else:\n        self.target.removeItem(key)\n        return value\n</code></pre>"},{"location":"reference/storage/#puepy.storage.BrowserStorage.popitem","title":"<code>popitem()</code>","text":"<p>Not implemented. Raises NotImplementedError.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always raised as the method is not implemented.</p> Source code in <code>puepy/storage.py</code> <pre><code>def popitem(self):\n    \"\"\"\n    Not implemented. Raises NotImplementedError.\n\n    Raises:\n        NotImplementedError: Always raised as the method is not implemented.\n    \"\"\"\n    raise NotImplementedError(\"popitem not implemented\")\n</code></pre>"},{"location":"reference/storage/#puepy.storage.BrowserStorage.reversed","title":"<code>reversed()</code>","text":"<p>Not implemented. Raises NotImplementedError.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always raised as the method is not implemented.</p> Source code in <code>puepy/storage.py</code> <pre><code>def reversed(self):\n    \"\"\"\n    Not implemented. Raises NotImplementedError.\n\n    Raises:\n        NotImplementedError: Always raised as the method is not implemented.\n    \"\"\"\n    raise NotImplementedError(\"reversed not implemented\")\n</code></pre>"},{"location":"reference/storage/#puepy.storage.BrowserStorage.setdefault","title":"<code>setdefault(key, default=None)</code>","text":"<p>Sets the value for the key if it does not already exist in the storage.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key for the item.</p> required <code>default</code> <p>The value to set if the key does not exist.</p> <code>None</code> <p>Returns:</p> Type Description <p>The value associated with the key, or the default value.</p> Source code in <code>puepy/storage.py</code> <pre><code>def setdefault(self, key, default=None):\n    \"\"\"\n    Sets the value for the key if it does not already exist in the storage.\n\n    Args:\n        key (str): The key for the item.\n        default: The value to set if the key does not exist.\n\n    Returns:\n        The value associated with the key, or the default value.\n    \"\"\"\n    if key in self:\n        return self[key]\n    else:\n        self[key] = default\n        return default\n</code></pre>"},{"location":"reference/storage/#puepy.storage.BrowserStorage.update","title":"<code>update(other)</code>","text":"<p>Updates the storage with items from another dictionary or iterable of key-value pairs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>A dictionary or iterable of key-value pairs to update the storage with.</p> required Source code in <code>puepy/storage.py</code> <pre><code>def update(self, other):\n    \"\"\"\n    Updates the storage with items from another dictionary or iterable of key-value pairs.\n\n    Args:\n        other: A dictionary or iterable of key-value pairs to update the storage with.\n    \"\"\"\n    for k, v in other.items():\n        self[k] = v\n</code></pre>"},{"location":"reference/storage/#puepy.storage.BrowserStorage.values","title":"<code>values()</code>","text":"<p>Returns a list of values in the storage.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of values.</p> Source code in <code>puepy/storage.py</code> <pre><code>def values(self):\n    \"\"\"\n    Returns a list of values in the storage.\n\n    Returns:\n        list: A list of values.\n    \"\"\"\n    return list(Object.values(self.target))\n</code></pre>"},{"location":"reference/tag/","title":"puepy.core.Tag","text":"<p>Tags should not be created directly</p> <p>In your <code>populate()</code> method, call t.tag_name() to create a tag. There's no reason an application develop should directly instanciate a tag instance and doing so is not supported.</p> <p>The most basic building block of a PuePy app. A Tag is a single HTML element. This is also the base class of <code>Component</code>, which is then the base class of <code>Page</code>.</p> <p>Attributes:</p> Name Type Description <code>default_classes</code> <code>list</code> <p>Default classes for the tag.</p> <code>default_attrs</code> <code>dict</code> <p>Default attributes for the tag.</p> <code>default_role</code> <code>str</code> <p>Default role for the tag.</p> <code>page</code> <code>Page</code> <p>The page the tag is on.</p> <code>router</code> <code>Router or None</code> <p>The router the application is using, if any.</p> <code>parent</code> <code>Tag</code> <p>The parent tag, component, or page.</p> <code>application</code> <code>Application</code> <p>The application instance.</p> <code>element</code> <p>The rendered element on the DOM. Raises ElementNotInDom if not found.</p> <code>children</code> <code>list</code> <p>The children of the tag.</p> <code>refs</code> <code>dict</code> <p>The refs of the tag.</p> <code>tag_name</code> <code>str</code> <p>The name of the tag.</p> <code>ref</code> <code>str</code> <p>The reference of the tag.</p> Source code in <code>puepy/core.py</code> <pre><code>class Tag:\n    \"\"\"\n    The most basic building block of a PuePy app. A Tag is a single HTML element. This is also the base class of\n    `Component`, which is then the base class of `Page`.\n\n    Attributes:\n        default_classes (list): Default classes for the tag.\n        default_attrs (dict): Default attributes for the tag.\n        default_role (str): Default role for the tag.\n        page (Page): The page the tag is on.\n        router (Router or None): The router the application is using, if any.\n        parent (Tag): The parent tag, component, or page.\n        application (Application): The application instance.\n        element: The rendered element on the DOM. Raises ElementNotInDom if not found.\n        children (list): The children of the tag.\n        refs (dict): The refs of the tag.\n        tag_name (str): The name of the tag.\n        ref (str): The reference of the tag.\n    \"\"\"\n\n    stack = []\n    population_stack = []\n    origin_stack = [[]]\n    component_stack = []\n    default_classes = []\n    default_attrs = {}\n    default_role = None\n\n    document = document\n\n    # noinspection t\n    def __init__(\n        self,\n        tag_name,\n        ref,\n        page: \"Page\" = None,\n        parent=None,\n        parent_component=None,\n        origin=None,\n        children=None,\n        **kwargs,\n    ):\n        # Kept so we can garbage collect them later\n        self._added_event_listeners = []\n\n        # Ones manually added, which we persist when reconfigured\n        self._manually_added_event_listeners = {}\n\n        # The rendered element\n        self._rendered_element = None\n\n        # Child nodes and origin refs\n        self.children = []\n        self.refs = {}\n\n        self.tag_name = tag_name\n        self.ref = ref\n\n        # Attrs that webcomponents create that we need to preserve\n        self._retained_attrs = {}\n\n        # Add any children passed to constructor\n        if children:\n            self.add(*children)\n\n        # Configure self._page\n        if isinstance(page, Page):\n            self._page = page\n        elif isinstance(self, Page):\n            self._page = self\n        elif page:\n            raise Exception(f\"Unknown page type {type(page)}\")\n        else:\n            raise Exception(\"No page passed\")\n\n        if \"id\" in kwargs:\n            self._element_id = kwargs[\"id\"]\n        elif self._page and self._page.application:\n            self._element_id = self._page.application.element_id_generator.get_id_for_element(self)\n        else:\n            self._element_id = f\"ppauto-{id(self)}\"\n\n        if isinstance(parent, Tag):\n            self.parent = parent\n            parent.add(self)\n        elif parent:\n            raise Exception(f\"Unknown parent type {type(parent)}: {repr(parent)}\")\n        else:\n            self.parent = None\n\n        if isinstance(parent_component, Component):\n            self.parent_component = parent_component\n        elif parent_component:\n            raise Exception(f\"Unknown parent_component type {type(parent_component)}: {repr(parent_component)}\")\n        else:\n            self.parent_component = None\n\n        self.origin = origin\n        self._children_generated = False\n\n        self._configure(kwargs)\n\n    def __del__(self):\n        if not is_server_side:\n            while self._added_event_listeners:\n                remove_event_listener(*self._added_event_listeners.pop())\n\n    @property\n    def application(self):\n        return self._page._application\n\n    def _configure(self, kwargs):\n        self._kwarg_event_listeners = _extract_event_handlers(kwargs)\n        self._handle_bind(kwargs)\n        self._handle_attrs(kwargs)\n\n    def _handle_bind(self, kwargs):\n        if \"bind\" in kwargs:\n            self.bind = kwargs.pop(\"bind\")\n            input_type = kwargs.get(\"type\")\n            tag_name = self.tag_name.lower()\n\n            if \"value\" in kwargs and not (tag_name == \"input\" and input_type == \"radio\"):\n                raise Exception(\"Cannot specify both 'bind' and 'value'\")\n\n        else:\n            self.bind = None\n\n    def _handle_attrs(self, kwargs):\n        self.attrs = self._retained_attrs.copy()\n        for k, v in kwargs.items():\n            if hasattr(self, f\"set_{k}\"):\n                getattr(self, f\"set_{k}\")(v)\n            else:\n                self.attrs[k] = v\n\n    def populate(self):\n        \"\"\"To be overwritten by subclasses, this method will define the composition of the element\"\"\"\n        pass\n\n    def precheck(self):\n        \"\"\"\n        Before doing too much work, decide whether rendering this tag should raise an error or not. This may be useful,\n        especially on a Page, to check if the user is authorized to view the page, for example:\n\n        Examples:\n            ``` py\n            def precheck(self):\n                if not self.application.state[\"authenticated_user\"]:\n                    raise exceptions.Unauthorized()\n            ```\n        \"\"\"\n        pass\n\n    def generate_children(self):\n        \"\"\"\n        Runs populate, but first adds self to self.population_stack, and removes it after populate runs.\n\n        That way, as populate is executed, self.population_stack can be used to figure out what the innermost populate()\n        method is being run and thus, where to send bind= parameters.\n        \"\"\"\n        self.origin_stack.append([])\n        self._refs_pending_removal = self.refs.copy()\n        self.refs = {}\n        self.population_stack.append(self)\n        try:\n            self.precheck()\n            self.populate()\n        finally:\n            self.population_stack.pop()\n            self.origin_stack.pop()\n\n    def render(self):\n        attrs = self.get_default_attrs()\n        attrs.update(self.attrs)\n\n        element = self._create_element(attrs)\n\n        self._render_onto(element, attrs)\n        self.post_render(element)\n        return element\n\n    def _create_element(self, attrs):\n        if \"xmlns\" in attrs:\n            element = self.document.createElementNS(attrs.get(\"xmlns\"), self.tag_name)\n        else:\n            element = self.document.createElement(self.tag_name)\n\n        element.setAttribute(\"id\", self.element_id)\n        if is_server_side:\n            element.setIdAttribute(\"id\")\n\n        self.configure_element(element)\n\n        return element\n\n    def configure_element(self, element):\n        pass\n\n    def post_render(self, element):\n        pass\n\n    @property\n    def element_id(self):\n        return self._element_id\n\n    @property\n    def element(self):\n        el = self.document.getElementById(self.element_id)\n        if el:\n            return el\n        else:\n            raise ElementNotInDom(self.element_id)\n\n    # noinspection t\n    def _render_onto(self, element, attrs):\n        self._rendered_element = element\n\n        # Handle classes\n        classes = self.get_render_classes(attrs)\n\n        if classes:\n            # element.className = \" \".join(classes)\n            element.setAttribute(\"class\", \" \".join(classes))\n\n        # Add attributes\n        for key, value in attrs.items():\n            if key not in (\"class_name\", \"classes\", \"class\"):\n                if hasattr(self, f\"handle_{key}_attr\"):\n                    getattr(self, f\"handle_{key}_attr\")(element, value)\n                else:\n                    if key.endswith(\"_\"):\n                        attr = key[:-1]\n                    else:\n                        attr = key\n                    attr = attr.replace(\"_\", \"-\")\n\n                    if isinstance(value, bool) or value is None:\n                        if value:\n                            element.setAttribute(attr, attr)\n                    elif isinstance(value, (str, int, float)):\n                        element.setAttribute(attr, value)\n                    else:\n                        element.setAttribute(attr, str(value))\n\n        if \"role\" not in attrs and self.default_role:\n            element.setAttribute(\"role\", self.default_role)\n\n        # Add event handlers\n        self._add_listeners(element, self._kwarg_event_listeners)\n        self._add_listeners(element, self._manually_added_event_listeners)\n\n        # Add bind\n        if self.bind and self.origin:\n            input_type = _element_input_type(element)\n\n            if type(self.bind) in [list, tuple]:\n                value = self.origin.state\n                for key in self.bind:\n                    value = value[key]\n            else:\n                value = self.origin.state[self.bind]\n\n            if input_type == \"checkbox\":\n                if is_server_side and value:\n                    element.setAttribute(\"checked\", value)\n                else:\n                    element.checked = bool(value)\n                    element.setAttribute(\"checked\", value)\n                event_type = \"change\"\n            elif input_type == \"radio\":\n                is_checked = value == element.value\n                if is_server_side and is_checked:\n                    element.setAttribute(\"checked\", is_checked)\n                else:\n                    element.checked = is_checked\n                    element.setAttribute(\"checked\", is_checked)\n                event_type = \"change\"\n            else:\n                if is_server_side:\n                    element.setAttribute(\"value\", value)\n                else:\n                    element.value = value\n                    element.setAttribute(\"value\", value)\n                event_type = \"input\"\n            self.add_event_listener(element, event_type, self.on_bind_input)\n        elif self.bind:\n            raise Exception(\"Cannot specify bind a valid parent component\")\n\n        self.render_children(element)\n\n    def _add_listeners(self, element, listeners):\n        for key, value in listeners.items():\n            key = key.replace(\"_\", \"-\")\n            if isinstance(value, (list, tuple)):\n                for handler in value:\n                    self.add_event_listener(element, key, handler)\n            else:\n                self.add_event_listener(element, key, value)\n\n    def render_children(self, element):\n        for child in self.children:\n            if isinstance(child, Slot):\n                if child.children:  # If slots don't have any children, don't bother.\n                    element.appendChild(child.render())\n            elif isinstance(child, Tag):\n                element.appendChild(child.render())\n            elif isinstance(child, html):\n                element.insertAdjacentHTML(\"beforeend\", str(child))\n            elif isinstance(child, str):\n                element.appendChild(self.document.createTextNode(child))\n            elif child is None:\n                pass\n            elif getattr(child, \"nodeType\", None) is not None:\n                # DOM element\n                element.appendChild(child)\n            else:\n                self.render_unknown_child(element, child)\n\n    def render_unknown_child(self, element, child):\n        \"\"\"\n        Called when the child is not a Tag, Slot, or html. By default, it raises an error.\n        \"\"\"\n        raise Exception(f\"Unknown child type {type(child)} onto {self}\")\n\n    def get_render_classes(self, attrs):\n        class_names, python_css_classes = merge_classes(\n            set(self.get_default_classes()),\n            attrs.pop(\"class_name\", []),\n            attrs.pop(\"classes\", []),\n            attrs.pop(\"class\", []),\n        )\n        self.page.python_css_classes.update(python_css_classes)\n        return class_names\n\n    def get_default_classes(self):\n        \"\"\"\n        Returns a shallow copy of the default_classes list.\n\n        This could be overridden by subclasses to provide a different default_classes list.\n\n        Returns:\n            (list): A shallow copy of the default_classes list.\n        \"\"\"\n        return self.default_classes.copy()\n\n    def get_default_attrs(self):\n        return self.default_attrs.copy()\n\n    def add_event_listener(self, element, event, listener):\n        \"\"\"\n        Just an internal wrapper around add_event_listener (JS function) that keeps track of what we added, so\n        we can garbage collect it later.\n\n        Should probably not be used outside this class.\n        \"\"\"\n        self._added_event_listeners.append((element, event, listener))\n        if not is_server_side:\n            add_event_listener(element, event, listener)\n\n    def mount(self, selector_or_element):\n        self.update_title()\n        if not self._children_generated:\n            with self:\n                self.generate_children()\n\n        if isinstance(selector_or_element, str):\n            element = self.document.querySelector(selector_or_element)\n        else:\n            element = selector_or_element\n\n        if not element:\n            raise RuntimeError(f\"Element {selector_or_element} not found\")\n\n        element.innerHTML = \"\"\n        element.appendChild(self.render())\n        self.recursive_call(\"on_ready\")\n        self.add_python_css_classes()\n\n    def add_python_css_classes(self):\n        \"\"\"\n        This is only done at the page level.\n        \"\"\"\n        pass\n\n    def recursive_call(self, method, *args, **kwargs):\n        \"\"\"\n        Recursively call a specified method on all child Tag objects.\n\n        Args:\n            method (str): The name of the method to be called on each Tag object.\n            *args: Optional arguments to be passed to the method.\n            **kwargs: Optional keyword arguments to be passed to the method.\n        \"\"\"\n        for child in self.children:\n            if isinstance(child, Tag):\n                child.recursive_call(method, *args, **kwargs)\n        getattr(self, method)(*args, **kwargs)\n\n    def on_ready(self):\n        pass\n\n    def _retain_implicit_attrs(self):\n        \"\"\"\n        Retain attributes set elsewhere\n        \"\"\"\n        try:\n            for attr in self.element.attributes:\n                if attr.name not in self.attrs and attr.name != \"id\":\n                    self._retained_attrs[attr.name] = attr.value\n        except ElementNotInDom:\n            pass\n\n    def on_redraw(self):\n        pass\n\n    def on_bind_input(self, event):\n        input_type = _element_input_type(event.target)\n        if input_type == \"checkbox\":\n            self.set_bind_value(self.bind, event.target.checked)\n        elif input_type == \"radio\":\n            if event.target.checked:\n                self.set_bind_value(self.bind, event.target.value)\n        elif input_type == \"number\":\n            value = event.target.value\n            try:\n                if \".\" in str(value):\n                    value = float(value)\n                else:\n                    value = int(value)\n            except (ValueError, TypeError):\n                pass\n            self.set_bind_value(self.bind, value)\n        else:\n            self.set_bind_value(self.bind, event.target.value)\n\n    def set_bind_value(self, bind, value):\n        if type(bind) in (list, tuple):\n            nested_dict = self.origin.state\n            for key in bind[:-1]:\n                nested_dict = nested_dict[key]\n            with self.origin.state.mutate(bind[0]):\n                nested_dict[bind[-1]] = value\n        else:\n            self.origin.state[self.bind] = value\n\n    @property\n    def page(self):\n        if self._page:\n            return self._page\n        elif isinstance(self, Page):\n            return self\n\n    @property\n    def router(self):\n        if self.application:\n            return self.application.router\n\n    @property\n    def parent(self):\n        return self._parent\n\n    @parent.setter\n    def parent(self, new_parent):\n        existing_parent = getattr(self, \"_parent\", None)\n        if new_parent == existing_parent:\n            if new_parent and self not in new_parent.children:\n                existing_parent.children.append(self)\n            return\n\n        if existing_parent and self in existing_parent.children:\n            existing_parent.children.remove(self)\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n\n        self._parent = new_parent\n\n    def add(self, *children):\n        for child in children:\n            if isinstance(child, Tag):\n                child.parent = self\n            else:\n                self.children.append(child)\n\n    def redraw(self):\n        if self in self.page.redraw_list:\n            self.page.redraw_list.remove(self)\n\n        try:\n            element = self.element\n        except ElementNotInDom:\n            return\n\n        if is_server_side:\n            old_active_element_id = None\n        else:\n            old_active_element_id = self.document.activeElement.id if self.document.activeElement else None\n\n            self.recursive_call(\"_retain_implicit_attrs\")\n\n        self.children = []\n\n        attrs = self.get_default_attrs()\n        attrs.update(self.attrs)\n\n        self.update_title()\n        with self:\n            self.generate_children()\n\n        staging_element = self._create_element(attrs)\n\n        self._render_onto(staging_element, attrs)\n\n        patch_dom_element(staging_element, element)\n\n        if old_active_element_id is not None:\n            el = self.document.getElementById(old_active_element_id)\n            if el:\n                el.focus()\n\n        self.recursive_call(\"on_redraw\")\n\n    def trigger_event(self, event, detail=None, **kwargs):\n        \"\"\"\n                Triggers an event to be consumed by code using this class.\n\n                Args:\n                    event (str): The name of the event to trigger. If the event name contains underscores, a warning message is printed suggesting to use dashes instead.\n                    detail (dict, optional): Additional data to be sent with the event. This should be a dictionary where the keys and values will be converted to JavaScript objects.\n                    **kwargs: Additional keyword arguments. These arguments are not used in the implementation of the method and are ignored.\n        \u00df\"\"\"\n        if \"_\" in event:\n            print(\"Triggering event with underscores. Did you mean dashes?: \", event)\n\n        # noinspection PyUnresolvedReferences\n        from pyscript.ffi import to_js\n\n        # noinspection PyUnresolvedReferences\n        from js import Object, Map\n\n        if detail:\n            event_object = to_js({\"detail\": Map.new(Object.entries(to_js(detail)))})\n        else:\n            event_object = to_js({})\n\n        self.element.dispatchEvent(CustomEvent.new(event, event_object))\n\n    def update_title(self):\n        \"\"\"\n        To be overridden by subclasses (usually pages), this method should update the Window title as needed.\n\n        Called on mounting or redraw.\n        \"\"\"\n        pass\n\n    def __enter__(self):\n        self.stack.append(self)\n        self.origin_stack[0].append(self)\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.stack.pop()\n        self.origin_stack[0].pop()\n        return False\n\n    def __str__(self):\n        return self.tag_name\n\n    def __repr__(self):\n        return f\"&lt;{self} ({id(self)})&gt;\"\n</code></pre>"},{"location":"reference/tag/#puepy.core.Tag._retain_implicit_attrs","title":"<code>_retain_implicit_attrs()</code>","text":"<p>Retain attributes set elsewhere</p> Source code in <code>puepy/core.py</code> <pre><code>def _retain_implicit_attrs(self):\n    \"\"\"\n    Retain attributes set elsewhere\n    \"\"\"\n    try:\n        for attr in self.element.attributes:\n            if attr.name not in self.attrs and attr.name != \"id\":\n                self._retained_attrs[attr.name] = attr.value\n    except ElementNotInDom:\n        pass\n</code></pre>"},{"location":"reference/tag/#puepy.core.Tag.add_event_listener","title":"<code>add_event_listener(element, event, listener)</code>","text":"<p>Just an internal wrapper around add_event_listener (JS function) that keeps track of what we added, so we can garbage collect it later.</p> <p>Should probably not be used outside this class.</p> Source code in <code>puepy/core.py</code> <pre><code>def add_event_listener(self, element, event, listener):\n    \"\"\"\n    Just an internal wrapper around add_event_listener (JS function) that keeps track of what we added, so\n    we can garbage collect it later.\n\n    Should probably not be used outside this class.\n    \"\"\"\n    self._added_event_listeners.append((element, event, listener))\n    if not is_server_side:\n        add_event_listener(element, event, listener)\n</code></pre>"},{"location":"reference/tag/#puepy.core.Tag.add_python_css_classes","title":"<code>add_python_css_classes()</code>","text":"<p>This is only done at the page level.</p> Source code in <code>puepy/core.py</code> <pre><code>def add_python_css_classes(self):\n    \"\"\"\n    This is only done at the page level.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/tag/#puepy.core.Tag.generate_children","title":"<code>generate_children()</code>","text":"<p>Runs populate, but first adds self to self.population_stack, and removes it after populate runs.</p> <p>That way, as populate is executed, self.population_stack can be used to figure out what the innermost populate() method is being run and thus, where to send bind= parameters.</p> Source code in <code>puepy/core.py</code> <pre><code>def generate_children(self):\n    \"\"\"\n    Runs populate, but first adds self to self.population_stack, and removes it after populate runs.\n\n    That way, as populate is executed, self.population_stack can be used to figure out what the innermost populate()\n    method is being run and thus, where to send bind= parameters.\n    \"\"\"\n    self.origin_stack.append([])\n    self._refs_pending_removal = self.refs.copy()\n    self.refs = {}\n    self.population_stack.append(self)\n    try:\n        self.precheck()\n        self.populate()\n    finally:\n        self.population_stack.pop()\n        self.origin_stack.pop()\n</code></pre>"},{"location":"reference/tag/#puepy.core.Tag.get_default_classes","title":"<code>get_default_classes()</code>","text":"<p>Returns a shallow copy of the default_classes list.</p> <p>This could be overridden by subclasses to provide a different default_classes list.</p> <p>Returns:</p> Type Description <code>list</code> <p>A shallow copy of the default_classes list.</p> Source code in <code>puepy/core.py</code> <pre><code>def get_default_classes(self):\n    \"\"\"\n    Returns a shallow copy of the default_classes list.\n\n    This could be overridden by subclasses to provide a different default_classes list.\n\n    Returns:\n        (list): A shallow copy of the default_classes list.\n    \"\"\"\n    return self.default_classes.copy()\n</code></pre>"},{"location":"reference/tag/#puepy.core.Tag.populate","title":"<code>populate()</code>","text":"<p>To be overwritten by subclasses, this method will define the composition of the element</p> Source code in <code>puepy/core.py</code> <pre><code>def populate(self):\n    \"\"\"To be overwritten by subclasses, this method will define the composition of the element\"\"\"\n    pass\n</code></pre>"},{"location":"reference/tag/#puepy.core.Tag.precheck","title":"<code>precheck()</code>","text":"<p>Before doing too much work, decide whether rendering this tag should raise an error or not. This may be useful, especially on a Page, to check if the user is authorized to view the page, for example:</p> <p>Examples:</p> <pre><code>def precheck(self):\n    if not self.application.state[\"authenticated_user\"]:\n        raise exceptions.Unauthorized()\n</code></pre> Source code in <code>puepy/core.py</code> <pre><code>def precheck(self):\n    \"\"\"\n    Before doing too much work, decide whether rendering this tag should raise an error or not. This may be useful,\n    especially on a Page, to check if the user is authorized to view the page, for example:\n\n    Examples:\n        ``` py\n        def precheck(self):\n            if not self.application.state[\"authenticated_user\"]:\n                raise exceptions.Unauthorized()\n        ```\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/tag/#puepy.core.Tag.recursive_call","title":"<code>recursive_call(method, *args, **kwargs)</code>","text":"<p>Recursively call a specified method on all child Tag objects.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The name of the method to be called on each Tag object.</p> required <code>*args</code> <p>Optional arguments to be passed to the method.</p> <code>()</code> <code>**kwargs</code> <p>Optional keyword arguments to be passed to the method.</p> <code>{}</code> Source code in <code>puepy/core.py</code> <pre><code>def recursive_call(self, method, *args, **kwargs):\n    \"\"\"\n    Recursively call a specified method on all child Tag objects.\n\n    Args:\n        method (str): The name of the method to be called on each Tag object.\n        *args: Optional arguments to be passed to the method.\n        **kwargs: Optional keyword arguments to be passed to the method.\n    \"\"\"\n    for child in self.children:\n        if isinstance(child, Tag):\n            child.recursive_call(method, *args, **kwargs)\n    getattr(self, method)(*args, **kwargs)\n</code></pre>"},{"location":"reference/tag/#puepy.core.Tag.render_unknown_child","title":"<code>render_unknown_child(element, child)</code>","text":"<p>Called when the child is not a Tag, Slot, or html. By default, it raises an error.</p> Source code in <code>puepy/core.py</code> <pre><code>def render_unknown_child(self, element, child):\n    \"\"\"\n    Called when the child is not a Tag, Slot, or html. By default, it raises an error.\n    \"\"\"\n    raise Exception(f\"Unknown child type {type(child)} onto {self}\")\n</code></pre>"},{"location":"reference/tag/#puepy.core.Tag.trigger_event","title":"<code>trigger_event(event, detail=None, **kwargs)</code>","text":"<pre><code>    Triggers an event to be consumed by code using this class.\n\n    Args:\n        event (str): The name of the event to trigger. If the event name contains underscores, a warning message is printed suggesting to use dashes instead.\n        detail (dict, optional): Additional data to be sent with the event. This should be a dictionary where the keys and values will be converted to JavaScript objects.\n        **kwargs: Additional keyword arguments. These arguments are not used in the implementation of the method and are ignored.\n</code></pre> <p>\u00df</p> Source code in <code>puepy/core.py</code> <pre><code>def trigger_event(self, event, detail=None, **kwargs):\n    \"\"\"\n            Triggers an event to be consumed by code using this class.\n\n            Args:\n                event (str): The name of the event to trigger. If the event name contains underscores, a warning message is printed suggesting to use dashes instead.\n                detail (dict, optional): Additional data to be sent with the event. This should be a dictionary where the keys and values will be converted to JavaScript objects.\n                **kwargs: Additional keyword arguments. These arguments are not used in the implementation of the method and are ignored.\n    \u00df\"\"\"\n    if \"_\" in event:\n        print(\"Triggering event with underscores. Did you mean dashes?: \", event)\n\n    # noinspection PyUnresolvedReferences\n    from pyscript.ffi import to_js\n\n    # noinspection PyUnresolvedReferences\n    from js import Object, Map\n\n    if detail:\n        event_object = to_js({\"detail\": Map.new(Object.entries(to_js(detail)))})\n    else:\n        event_object = to_js({})\n\n    self.element.dispatchEvent(CustomEvent.new(event, event_object))\n</code></pre>"},{"location":"reference/tag/#puepy.core.Tag.update_title","title":"<code>update_title()</code>","text":"<p>To be overridden by subclasses (usually pages), this method should update the Window title as needed.</p> <p>Called on mounting or redraw.</p> Source code in <code>puepy/core.py</code> <pre><code>def update_title(self):\n    \"\"\"\n    To be overridden by subclasses (usually pages), this method should update the Window title as needed.\n\n    Called on mounting or redraw.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"tutorial/00-using-this-tutorial/","title":"Using This Tutorial","text":"<p>Each of the examples in this tutorial can be run on PyScript.com, a web environment that lets you write, test, and share PyScript code. Alternatively, you can clone the PuePy git repo and run a live web server with each example included.</p> <p>The PyScript.com environment uses the PuePy <code>.whl</code> file, as downloadable from PyPi, while the examples in the git repository are served with PuePy directly from source files on disk.</p>"},{"location":"tutorial/00-using-this-tutorial/#using-pyscriptcom","title":"Using PyScript.com","text":"<p>Navigate to https://pyscript.com/@kkinder/puepy-tutorial/latest and you are greeted with a list of files on the left, a code editor in the middle, and a running example on the left. Each chapter in the tutorial corresponds with a directory in <code>tutorial</code> folder on the left.</p> <p></p> <p>You can clone the entire examples project and edit it yourself to continue your learning:</p> <p></p> <p>Once cloned you make your own changes and experiment with them in real time.</p>"},{"location":"tutorial/00-using-this-tutorial/#editing-locally","title":"Editing locally","text":"<p>After cloning puepy on git, you can run the examples using a simple script:</p> <p></p> <p>http://localhost:8000/ show you a list of examples</p> <p></p> <p>As you edit them in the <code>examples</code> folder and reload the window, your changes will be live.</p>"},{"location":"tutorial/00-using-this-tutorial/#live-examples","title":"Live Examples","text":"<p>Most of the examples you see live in this tutorial include example code running live in a browser like this:</p> <p></p> <p>There, you can see the running example inline with its explanation. You can also edit the code on PyScript.com by navigating to its example folder and cloning the project, as described above.</p>"},{"location":"tutorial/01-hello-world/","title":"Hello, World! 0.6.2","text":"<p>0.6.2 Let's start with the simplest possible: Hello, World!</p> <p>https://kkinder.pyscriptapps.com/puepy-tutorial/latest/tutorial/01_hello_world/index.htmlEdit</p> hello_world.pyindex.htmlpyscript.json <pre><code>from puepy import Application, Page, t\n\napp = Application()\n\n\n@app.page()\nclass HelloWorldPage(Page):\n    def populate(self):\n        t.h1(\"Hello, World!\")\n\n\napp.mount(\"#app\")\n</code></pre> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;title&gt;PuePy Hello, World&lt;/title&gt;\n  &lt;meta charset=\"UTF-8\"&gt;\n  &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt;\n  &lt;link rel=\"stylesheet\" href=\"https://pyscript.net/releases/2025.2.2/core.css\"&gt;\n  &lt;script type=\"module\" src=\"https://pyscript.net/releases/2025.2.2/core.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div id=\"app\"&gt;Loading...&lt;/div&gt;\n&lt;script type=\"mpy\" src=\"./hello_world.py\" config=\"../../pyscript.json\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <pre><code>{\n  \"name\": \"PuePy Tutorial\",\n  \"debug\": true,\n  \"files\": {},\n  \"js_modules\": {\n    \"main\": {\n      \"https://cdn.jsdelivr.net/npm/morphdom@2.7.4/+esm\": \"morphdom\"\n    }\n  },\n  \"packages\": [\n    \"./puepy-0.6.2-py3-none-any.whl\"\n  ]\n}\n</code></pre>"},{"location":"tutorial/01-hello-world/#including-pyscript","title":"Including PyScript","text":"<p>Let's start with the HTML. To use PuePy, we include PyScript from its CDN:</p> index.html<pre><code>  &lt;link rel=\"stylesheet\" href=\"https://pyscript.net/releases/2025.2.2/core.css\"&gt;\n  &lt;script type=\"module\" src=\"https://pyscript.net/releases/2025.2.2/core.js\"&gt;&lt;/script&gt;\n</code></pre> <p>Then, we include our PyScript config file and also execute our <code>hello_world.py</code> file:</p> index.html<pre><code>&lt;script type=\"mpy\" src=\"./hello_world.py\" config=\"../../pyscript.json\"&gt;&lt;/script&gt;\n</code></pre>"},{"location":"tutorial/01-hello-world/#pyscript-configuration","title":"PyScript configuration","text":"<p>PyScript Configuration</p> <p>The official PyScript documentation has more information on PyScript configuration.</p> <p>The PyScript configuration must, at minimum, tell PyScript to use PuePy (usually as a package) and include Morphdom, which is a dependency of PuePy.</p>"},{"location":"tutorial/01-hello-world/#the-python-code","title":"The Python Code","text":"<p>Let's take a look at our Python code which actually renders Hello, World.</p> <p>First, we import <code>Application</code>, <code>Page</code>, and <code>t</code> from <code>puepy</code>:</p> <pre><code>from puepy import Application, Page, t\n</code></pre> <p>To use PuePy, you must always create an <code>Application</code> instance, even if the application only has one page:</p> <pre><code>app = Application()\n</code></pre> <p>Next, we define a Page and use the <code>t</code> singleton to compose our DOM in the <code>populate()</code> method. Don't worry too much about the details for now; just know that this is how we define pages and components in PuePy:</p> <pre><code>@app.page()\nclass HelloWorldPage(Page):\n    def populate(self):\n        t.h1(\"Hello, World!\")\n</code></pre> <p>Finally, we tell PuePy where to mount the application. This is where the application will be rendered in the DOM. The <code>#app</code> element was already defined in our HTML file.</p> <pre><code>app.mount(\"#app\")\n</code></pre> <p>And with that, the page is added to the application, and the application is mounted in the element with id <code>app</code>.</p> <p>Watching for Errors</p> <p>Use your browser's development console to watch for any errors.</p>"},{"location":"tutorial/02-hello-name/","title":"Hello, Name","text":"<p>In this chapter, we introduce state and variables by creating a simple form that asks for a name and greets the user.</p> <p>https://kkinder.pyscriptapps.com/puepy-tutorial/latest/tutorial/02_hello_name/index.htmlEdit</p> <p>The html and pyscript configuration are the same as in the previous Hello, World chapter, so we will only study the Python code. Expand the annotations in the code below for a more detail explanation of the changes:</p> hello_name.py<pre><code>from puepy import Application, Page, t\n\napp = Application()\n\n\n@app.page()\nclass HelloNamePage(Page):\n    def initial(self):\n        return {\"name\": \"\"}  # (1)\n\n    def populate(self):\n        if self.state[\"name\"]:  # (2)\n            t.h1(f\"Hello, {self.state['name']}!\")\n        else:\n            t.h1(f\"Why don't you tell me your name?\")\n\n        with t.div(style=\"margin: 1em\"):\n            t.input(bind=\"name\", placeholder=\"name\", autocomplete=\"off\")  # (3)\n\n\napp.mount(\"#app\")\n</code></pre> <ol> <li>The <code>initial()</code> method defines the page's initial working state. In this case, it returns a dictionary with a    single key, <code>name</code>, which is initially an empty string.</li> <li>We check the value of <code>self.state[\"name\"]</code> and renders different content based on that value.</li> <li>We define an <code>input</code> element with a <code>bind=\"name\"</code> parameter. This binds the input element to the <code>name</code> key in the    page's state. When the input value changes, the state is updated, and the page is re-rendered.</li> </ol>"},{"location":"tutorial/02-hello-name/#reactivity","title":"Reactivity","text":"<p>A page or component's initial state is defined by the <code>initial()</code> method. If implemented, it should return a dictionary, which is then stored as a special reactive dictionary, <code>self.state</code>. As the state is modified, the component redraws, updating the DOM as needed.</p> <p>Modifying <code>.state</code> values in-place will not work</p> <p>For complex objects like lists and dictionaries, you cannot modify them in-place and expect the component to re-render.</p> <pre><code># THESE WILL NOT WORK:\nself.state[\"my_list\"].append(\"spam\")\nself.state[\"my_dict\"][\"spam\"] = \"eggs\"\n</code></pre> <p>This is because PuePy's ReactiveDict cannot detect \"deep\" changes to state automatically. If you are modifying objects in-place, use <code>with self.state.mutate()</code> as a context manager:</p> <pre><code># This will work\nwith self.state.mutate(\"my_list\", \"my_dict\"):\n    self.state[\"my_list\"].append(\"spam\")\n    self.state[\"my_dict\"][\"spam\"] = \"eggs\"\n</code></pre> More information on reactivity <p>For more information on reactivity in PuePy, see the Reactivity Developer Guide.</p>"},{"location":"tutorial/03-events/","title":"Counter","text":"<p>In this chapter, we introduce event handlers. Take a look at this demo, with plus and minus buttons that increment and decrement a counter. You may remember it from the pupy.dev homepage.</p> <p>https://kkinder.pyscriptapps.com/puepy-tutorial/latest/tutorial/03_counter/index.htmlEdit</p> <p>In this example, we bind two events to event handlers. Follow along with the annotations in the code below for a more detailed explanation:</p> counter.py<pre><code>from puepy import Application, Page, t\n\napp = Application()\n\n\n@app.page()\nclass CounterPage(Page):\n    def initial(self):\n        return {\"current_value\": 0}\n\n    def populate(self):\n        with t.div(classes=\"button-box\"):\n            t.button(\"-\", \n                     classes=[\"button\", \"decrement-button\"],\n                     on_click=self.on_decrement_click)  # (1)\n            t.span(str(self.state[\"current_value\"]), classes=\"count\")\n            t.button(\"+\", \n                     classes=\"button increment-button\",\n                     on_click=self.on_increment_click)  # (2)\n\n    def on_decrement_click(self, event):\n        self.state[\"current_value\"] -= 1  # (3)\n\n    def on_increment_click(self, event):\n        self.state[\"current_value\"] += 1  # (4)\n\n\napp.mount(\"#app\")\n</code></pre> <ol> <li>The <code>on_click</code> parameter is passed to the <code>button</code> tag, which binds the <code>on_decrement_click</code> method to the button's click event.</li> <li>The <code>on_click</code> parameter is passed to the <code>button</code> tag, which binds the <code>on_increment_click</code> method to the button's click event.</li> <li>The <code>on_decrement_click</code> method decrements the <code>current_value</code> key in the page's state.</li> <li>The <code>on_increment_click</code> method increments the <code>current_value</code> key in the page's state.</li> </ol> <p>Tip</p> <p>The <code>event</code> parameter sent to event handlers is the same as it is in JavaScript. You can call <code>event.preventDefault()</code> or <code>event.stopPropagation()</code> as needed.</p> <p>As before, because we are modifying the state directly, the page will re-render automatically. This is the power of PuePy's reactivity system.</p>"},{"location":"tutorial/04-refs/","title":"Using Refs","text":"<p>Let's introduce our first bug. Try typing a word in the input box in the demo below.</p> <p>https://kkinder.pyscriptapps.com/puepy-tutorial/latest/tutorial/04_refs_problem/index.htmlEdit</p> <p>Notice that as you type, each time the page redraws, your input loses focus. This is because PuePy doesn't know which elements are supposed to \"match\" the ones from the previous refresh, and the ordering is now different. The original <code>&lt;input&gt;</code> is being discarded each refresh and replaced with a new one.</p> <p>Now try the fixed version:</p> <p>https://kkinder.pyscriptapps.com/puepy-tutorial/latest/tutorial/04_refs_problem/solution.htmlEdit</p> <p>Here's the problem code and the fixed code. Notice the addition of a <code>ref=</code> in the fixed version.</p> Problem CodeFixed Code <pre><code>@app.page()\nclass RefsProblemPage(Page):\n    def initial(self):\n        return {\"word\": \"\"}\n\n    def populate(self):\n        t.h1(\"Problem: DOM elements are re-created\")\n        if self.state[\"word\"]:\n            for char in self.state[\"word\"]:\n                t.span(char, classes=\"char-box\")\n        with t.div(style=\"margin-top: 1em\"):\n            t.input(bind=\"word\", placeholder=\"Type a word\")\n</code></pre> <pre><code>@app.page()\nclass RefsSolutionPage(Page):\n    def initial(self):\n        return {\"word\": \"\"}\n\n    def populate(self):\n        t.h1(\"Solution: Use ref=\")\n        if self.state[\"word\"]:\n            for char in self.state[\"word\"]:\n                t.span(char, classes=\"char-box\")\n        with t.div(style=\"margin-top: 1em\"):\n            t.input(bind=\"word\", placeholder=\"Type a word\", ref=\"enter_word\")\n</code></pre>"},{"location":"tutorial/04-refs/#using-refs-to-preserve-elements-between-refreshes","title":"Using refs to preserve elements between refreshes","text":"<p>To tell PuePy not to garbage collect an element, but to reuse it between redraws, just give it a <code>ref=</code> parameter. The ref should be unique to the component you're coding: that is, each ref should be unique among all elements created in the <code>populate()</code> method you're writing.</p> <p>When PuePy finds an element with a ref, it will reuse that ref if it existed in the last refresh, modifying it with any updated parameters passed to it.</p> <p>Using references in your code</p> <p>The <code>self.refs</code> dictionary is available to you in your page or component. You can access elements by their ref name, like <code>self.refs[\"enter_word\"]</code>.</p>"},{"location":"tutorial/05-watchers/","title":"Watchers","text":"<p>We've introduced reactivity, but what happens when you want to monitor specific variables for changes? In PuePy, you can use <code>on_&lt;variable&gt;_change</code> methods in your components to watch for changes in specific variables. In the example below, try guessing the number 4:</p> <p>https://kkinder.pyscriptapps.com/puepy-tutorial/latest/tutorial/05_watchers/index.htmlEdit</p> watchers.py<pre><code>@app.page()\nclass WatcherPage(Page):\n    def initial(self):\n        self.winner = 4\n\n        return {\"number\": \"\", \"message\": \"\"}\n\n    def populate(self):\n        t.h1(\"Can you guess a number between 1 and 10?\")\n\n        with t.div(style=\"margin: 1em\"):\n            t.input(bind=\"number\", placeholder=\"Enter a guess\", autocomplete=\"off\", type=\"number\", maxlength=1)\n\n        if self.state[\"message\"]:\n            t.p(self.state[\"message\"])\n\n    def on_number_change(self, event):  # (1)\n        try:\n            if int(self.state[\"number\"]) == self.winner:\n                self.state[\"message\"] = \"You guessed the number!\"\n            else:\n                self.state[\"message\"] = \"Keep trying...\"\n        except (ValueError, TypeError):\n            self.state[\"message\"] = \"\"\n</code></pre> <ol> <li>The function name, <code>on_number_change</code> is automatically registered based on the pattern of <code>on_&lt;variable&gt;_change</code>. The event parameter is passed up from the original JavaScript event that triggered the change.</li> </ol> <p>The watcher method itself changes the <code>self.state[\"message\"]</code> variable based on the value of <code>self.state[\"number\"]</code>. If the number is equal to the <code>self.winner</code> constant, the message is updated to \"You guessed the number!\" Otherwise, the message is set to \"Keep trying...\". The state is once again changed and the page is re-rendered.</p>"},{"location":"tutorial/06-components/","title":"Components","text":"<p>Components are a way to encapsulate a piece of UI that can be reused throughout your application. In this example, we'll create a <code>Card</code> component and use it multiple times on a page, each time using slots to fill in content.</p> <p>https://kkinder.pyscriptapps.com/puepy-tutorial/latest/tutorial/06_components/index.htmlEdit</p> Component DefinitionComponent Usage <pre><code>@t.component()  # (1)!\nclass Card(Component):  # (2)!\n    props = [\"type\", \"button_text\"]  # (3)!\n\n    card = CssClass(  # (4)!\n        margin=\"1em\",\n        padding=\"1em\",\n        background_color=\"#efefef\",\n        border=\"solid 2px #333\",\n    )\n\n    default_classes = [card]\n\n    type_styles = {\n        \"success\": success,\n        \"warning\": warning,\n        \"error\": error,\n    }\n\n    def populate(self):\n        with t.h2(classes=[self.type_styles[self.type]]):\n            self.insert_slot(\"card-header\")    # (5)!\n        with t.p():\n            self.insert_slot()    # (6)!\n        t.button(self.button_text, on_click=self.on_button_click)\n\n    def on_button_click(self, event):\n        self.trigger_event(\"my-custom-event\",\n            detail={\"type\": self.type})  # (7)!\n</code></pre> <ol> <li>The <code>@t.component()</code> decorator registers the class as a component for use elsewhere.</li> <li>All components should subclass the <code>puepy.Component</code> class.</li> <li>The <code>props</code> attribute is a list of properties that can be passed to the component.</li> <li>Classes can be defined programmatically in Python. Class names are automatically generated for each instance, so they're scoped like Python instances.</li> <li><code>default_classes</code> is a list of CSS classes that will be applied to the component by default.</li> <li>The <code>insert_slot</code> method is used to insert content into a named slot. In this case, we are inserting content into the <code>card-header</code> slot.</li> <li>Unnamed, or default slots, can be filled by calling <code>insert_slot</code> without a name.</li> <li><code>trigger_event</code> is used to trigger a custom event. Notice the detail dictionary. This pattern matches the JavaScript <code>CustomEvent</code> API.</li> </ol> <pre><code>@app.page()\nclass ComponentPage(Page):\n    def initial(self):\n        return {\"message\": \"\"}\n\n    def populate(self):\n        t.h1(\"Components are useful\")\n\n        with t.card(type=\"success\",  # (1)\n                    on_my_custom_event=self.handle_custom_event) as card:  # (2)\n            with card.slot(\"card-header\"):\n                t(\"Success!\")  # (3)\n            with card.slot():\n                t(\"Your operation worked\")  # (4)\n\n        with t.card(type=\"warning\", on_my_custom_event=self.handle_custom_event) as card:\n            with card.slot(\"card-header\"):\n                t(\"Warning!\")\n            with card.slot():\n                t(\"Your operation may not work\")\n\n        with t.card(type=\"error\", on_my_custom_event=self.handle_custom_event) as card:\n            with card.slot(\"card-header\"):\n                t(\"Failure!\")\n            with card.slot():\n                t(\"Your operation failed\")\n\n        if self.state[\"message\"]:\n            t.p(self.state[\"message\"])\n\n    def handle_custom_event(self, event):  # (5)\n        self.state[\"message\"] = f\"Custom event from card with type {event.detail.get('type')}\"\n</code></pre> <ol> <li>The <code>card</code> component is used with the <code>type</code> prop set to <code>\"success\"</code>.</li> <li>The <code>my-custom-event</code> event is bound to the <code>self.handle_custom_event</code> method.</li> <li>The content for the <code>card-header</code> slot, as defined in the <code>Card</code> component, is populated with \"Success!\".</li> <li>The default slot is populated with \"Your operation worked\". Default slots are not named.</li> <li>The <code>handle_custom_event</code> method is called when the <code>my-custom-event</code> event is triggered.</li> </ol>"},{"location":"tutorial/06-components/#slots","title":"Slots","text":"<p>Slots are a way to pass content into a component. A component can define one or more slots, and the calling code can fill in the slots with content. In the example above, the <code>Card</code> component defines two slots: <code>card-header</code> and the default slot. The calling code fills in the slots by calling <code>card.slot(\"card-header\")</code> and <code>card.slot()</code>.</p> Defining Slots in a componentFilling Slots in the calling code <pre><code>with t.h2():\n    self.insert_slot(\"card-header\")\nwith t.p():\n    self.insert_slot()  # (1)\n</code></pre> <ol> <li>If you don't pass a name, it defaults to the main slot</li> </ol> <pre><code>with t.card() as card:\n    with card.slot(\"card-header\"):\n        t(\"Success!\")\n    with card.slot():\n        t(\"Your operation worked\")\n</code></pre> <p>Consuming Slots</p> <p>When consuming components with slots, to populate a slot, you do not call <code>t.slot</code>. You call <code>.slot</code> directly on the component instance provided by the context manager:</p> <pre><code>with t.card() as card:\n    with card.slot(\"card-header\"):  # (1)\n        t(\"Success!\")\n</code></pre> <ol> <li>Notice <code>card.slot</code> is called, not <code>t.slot</code> or <code>self.slot</code>.</li> </ol> More information on components <p>For more information on components in PuePy, see the Component Developer Guide.</p>"},{"location":"tutorial/07-routing/","title":"Routing","text":"<p>For single page apps (SPAs) or even complex pages with internal navigation, PuePy's client-side routing feature renders different pages based on the URL and provides a way of linking between various routes. Use of the router is optional and if no router is installed, the application will always render the default page.</p> <p>https://kkinder.pyscriptapps.com/puepy-tutorial/latest/tutorial/07_routing/index.htmlEdit</p> <p>URL Changes</p> <p>In the embedded example above, the \"URL\" does not change because the embedded example is not a full web page. In a full web page, the URL would change to reflect the current page. Try opening the example in a new window to see the URL change.</p> <p>Inspired by Flask's simple and elegant routing system, PuePy uses decorators on page classes to define routes and parameters. The router can be configured to use either hash-based or history-based routing. Consider this example's source code:</p> routing.py<pre><code>from puepy import Application, Page, Component, t\nfrom puepy.router import Router\n\napp = Application()\napp.install_router(Router, link_mode=Router.LINK_MODE_HASH)  # (1)\n\npets = {\n    \"scooby\": {\"name\": \"Scooby-Doo\", \"type\": \"dog\", \"character\": \"fearful\"},\n    \"garfield\": {\"name\": \"Garfield\", \"type\": \"cat\", \"character\": \"lazy\"},\n    \"snoopy\": {\"name\": \"Snoopy\", \"type\": \"dog\", \"character\": \"playful\"},\n}\n\n\n@t.component()\nclass Link(Component):  # (2)\n    props = [\"args\"]\n    enclosing_tag = \"a\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        self.add_event_listener(\"click\", self.on_click)\n\n    def set_href(self, href):\n        if issubclass(href, Page):\n            args = self.args or {}\n            self._resolved_href = self.page.router.reverse(href, **args)\n        else:\n            self._resolved_href = href\n\n        self.attrs[\"href\"] = self._resolved_href\n\n    def on_click(self, event):\n        if (\n            isinstance(self._resolved_href, str)\n            and self._resolved_href[0] in \"#/\"\n            and self.page.router.navigate_to_path(self._resolved_href)\n        ):\n            # A page was found; prevent navigation and navigate to page\n            event.preventDefault()\n\n\n@app.page(\"/pet/&lt;pet_id&gt;\")  # (3)\nclass PetPage(Page):\n    props = [\"pet_id\"]\n\n    def populate(self):\n        pet = pets.get(self.pet_id)\n        t.h1(\"Pet Information\")\n        with t.dl():\n            for k, v in pet.items():\n                t.dt(k)\n                t.dd(v)\n        t.link(\"Back to Homepage\", href=DefaultPage)  # (4)\n\n\n@app.page()\nclass DefaultPage(Page):\n    def populate(self):\n        t.h1(\"PuePy Routing Demo: Pet Listing\")\n        with t.ul():\n            for pet_id, pet_details in pets.items():\n                with t.li():\n                    t.link(pet_details[\"name\"],\n                           href=PetPage,\n                           args={\"pet_id\": pet_id})  # (5)\n\n\napp.mount(\"#app\")\n</code></pre> <ol> <li>The router is installed with the <code>link_mode</code> set to <code>Router.LINK_MODE_HASH</code>. This sets the router to use hash-based routing.</li> <li>The <code>Link</code> component is a custom component that creates links to other pages. It uses the router to navigate to the specified page.</li> <li>The <code>PetPage</code> class is decorated with a route. The <code>pet_id</code> parameter is parsed from the URL.</li> <li>The <code>Link</code> component is used to create a link back to the homepage, as passed by the <code>href</code> parameter.</li> <li>The <code>Link</code> component is used to create links to each pet's page, passing the <code>pet_id</code> as a parameter.</li> </ol>"},{"location":"tutorial/07-routing/#installing-the-router","title":"Installing the router","text":"<p>The router is installed with the <code>install_router</code> method on the application instance:</p> <pre><code>app.install_router(Router, link_mode=Router.LINK_MODE_HASH)\n</code></pre> <p>If you wanted to use html5 history mode (see the Router developer guide), you would set <code>link_mode=Router.LINK_MODE_HISTORY</code>.</p>"},{"location":"tutorial/07-routing/#the-default-page","title":"The default page","text":"<p>The default page is rendered for the \"root\" URL or when no URL is specified. The default page is defined with no path:</p> <pre><code>@app.page()\nclass DefaultPage(Page):\n    ...\n</code></pre> More information on the router <p>For more information on the router, see the Router Developer Guide.</p>"},{"location":"tutorial/08-pypi-libraries/","title":"Using PyPi Libraries","text":"<p>Let's make use of a PyPi library in our project. In this example, we'll use BeautifulSoup to parse an HTML document and actually generate a PuePy component that would render the same content.</p> <p>https://kkinder.pyscriptapps.com/puepy-tutorial/latest/tutorial/08_libraries/index.htmlEdit</p> <p>Small embedded example</p> <p>This example may be more useful in a full browser window. Open in new window</p>"},{"location":"tutorial/08-pypi-libraries/#using-full-cpythonpyodide","title":"Using Full CPython/Pyodide","text":"<p>To make use of a library like BeautifulSoup, we will configure PuePy to use the full CPython/Pyoide runtime, rather than the more minimal MicroPython runtime. This is done by specifying the runtime in the <code>&lt;script&gt;</code> tag in index.html:</p> <pre><code>&lt;script type=\"py\" src=\"./libraries.py\" config=\"./pyscript-bs.json\"&gt;&lt;/script&gt;\n</code></pre>"},{"location":"tutorial/08-pypi-libraries/#requiring-packages-from-pypi","title":"Requiring packages from pypi","text":"<p>In <code>pyscript-bs.json</code>, we also must specify that we need BeautifulSoup4. This is done by adding it to the <code>packages</code> section of the config file:</p> pyscript-bs.json<pre><code>{\n  \"name\": \"PuePy Tutorial\",\n  \"debug\": true,\n  \"packages\": [\n    \"./puepy-0.5.0-py3-none-any.whl\",\n    \"beautifulsoup4\"\n  ],\n  \"js_modules\": {\n    \"main\": {\n      \"https://cdn.jsdelivr.net/npm/morphdom@2.7.4/+esm\": \"morphdom\"\n    }\n  }\n}\n</code></pre> <p>The <code>type</code> attribute in the PyScript <code>&lt;script&gt;</code> tag can have two values:</p> <ul> <li><code>mpy</code>: Use the MicroPython runtime</li> <li><code>py</code>: Use the CPython/Pyodide runtime</li> </ul> <p>See Also</p> <p>See also the runtimes developer guide for more information on runtimes.</p> <p>Once the dependencies are specified in the config file, we can import the library in our source file:</p> <pre><code>from bs4 import BeautifulSoup, Comment\n</code></pre> Full Example Source libraries.py<pre><code>import re\nfrom bs4 import BeautifulSoup, Comment\nfrom puepy import Application, Page, t\n\napp = Application()\n\nPYTHON_KEYWORDS = [\n    \"false\",\n    \"none\",\n    \"true\",\n    \"and\",\n    \"as\",\n    \"assert\",\n    \"async\",\n    \"await\",\n    \"break\",\n    \"class\",\n    \"continue\",\n    \"def\",\n    \"del\",\n    \"elif\",\n    \"else\",\n    \"except\",\n    \"finally\",\n    \"for\",\n    \"from\",\n    \"global\",\n    \"if\",\n    \"import\",\n    \"in\",\n    \"is\",\n    \"lambda\",\n    \"nonlocal\",\n    \"not\",\n    \"or\",\n    \"pass\",\n    \"raise\",\n    \"return\",\n    \"try\",\n    \"while\",\n    \"with\",\n    \"yield\",\n]\n\n\nclass TagGenerator:\n    def __init__(self, indentation=4):\n        self.indent_level = 0\n        self.indentation = indentation\n\n    def indent(self):\n        return \" \" * self.indentation * self.indent_level\n\n    def sanitize(self, key):\n        key = re.sub(r\"\\W\", \"_\", key)\n        if not key[0].isalpha():\n            key = f\"_{key}\"\n        if key == \"class\":\n            key = \"classes\"\n        elif key.lower() in PYTHON_KEYWORDS:\n            key = f\"{key}_\"\n        return key\n\n    def generate_tag(self, tag):\n        attr_list = [\n            f\"{self.sanitize(key)}={repr(' '.join(value) if isinstance(value, list) else value)}\"\n            for key, value in tag.attrs.items()\n        ]\n\n        underscores_tag_name = tag.name.replace(\"-\", \"_\")\n\n        sanitized_tag_name = self.sanitize(underscores_tag_name)\n        if sanitized_tag_name != underscores_tag_name:\n            # For the rare case where it really just has to be the original tag\n            attr_list.append(f\"tag={repr(tag.name)}\")\n\n        attributes = \", \".join(attr_list)\n\n        return (\n            f\"{self.indent()}with t.{sanitized_tag_name}({attributes}):\"\n            if tag.contents\n            else f\"{self.indent()}t.{sanitized_tag_name}({attributes})\"\n        )\n\n    def iterate_node(self, node):\n        output = []\n        for child in node.children:\n            if child.name:  # Element\n                output.append(self.generate_tag(child))\n                self.indent_level += 1\n                if child.contents:\n                    output.extend(self.iterate_node(child))\n                self.indent_level -= 1\n            elif isinstance(child, Comment):\n                for line in child.strip().split(\"\\n\"):\n                    output.append(f\"{self.indent()}# {line}\")\n            elif isinstance(child, str) and child.strip():  # Text node\n                output.append(f\"{self.indent()}t({repr(child.strip())})\")\n        return output\n\n    def generate_app_root(self, node, generate_full_file=True):\n        header = (\n            [\n                \"from puepy import Application, Page, t\",\n                \"\",\n                \"app = Application()\",\n                \"\",\n                \"@app.page()\",\n                \"class DefaultPage(Page):\",\n                \"    def populate(self):\",\n            ]\n            if generate_full_file\n            else []\n        )\n        self.indent_level = 2 if generate_full_file else 0\n        body = self.iterate_node(node)\n        return \"\\n\".join(header + body)\n\n\ndef convert_html_to_context_manager(html, indent=4, generate_full_file=True):\n    soup = BeautifulSoup(html, \"html.parser\")\n    generator = TagGenerator(indentation=indent)\n    return generator.generate_app_root(soup, generate_full_file=generate_full_file)\n\n\n@app.page()\nclass DefaultPage(Page):\n    def initial(self):\n        return {\"input\": \"\", \"output\": \"\", \"error\": \"\", \"generate_full_file\": True}\n\n    def populate(self):\n        with t.div(classes=\"section\"):\n            t.h1(\"Convert HTML to PuePy syntax with BeautifulSoup\", classes=\"title is-1\")\n            with t.div(classes=\"columns is-variable is-8 is-multiline\"):\n                with t.div(classes=\"column is-half-desktop is-full-mobile\"):\n                    with t.div(classes=\"field\"):\n                        t.div(\"Enter HTML Here\", classes=\"label\")\n                        t.textarea(bind=\"input\", classes=\"textarea\")\n                with t.div(classes=\"column is-half-desktop is-full-mobile\"):\n                    with t.div(classes=\"field\"):\n                        t.div(\"Output\", classes=\"label\")\n                        t.textarea(bind=\"output\", classes=\"textarea\", readonly=True)\n            with t.div(classes=\"field is-grouped\"):\n                with t.p(classes=\"control\"):\n                    t.button(\"Convert\", classes=\"button is-primary\", on_click=self.on_convert_click)\n                with t.p(classes=\"control\"):\n                    with t.label(classes=\"checkbox\"):\n                        t.input(bind=\"generate_full_file\", type=\"checkbox\")\n                        t(\" Generate full file\")\n            if self.state[\"error\"]:\n                with t.div(classes=\"notification is-danger\"):\n                    t(self.state[\"error\"])\n\n    def on_convert_click(self, event):\n        self.state[\"error\"] = \"\"\n        try:\n            self.state[\"output\"] = convert_html_to_context_manager(\n                self.state[\"input\"], generate_full_file=self.state[\"generate_full_file\"]\n            )\n        except Exception as e:\n            self.state[\"error\"] = str(e)\n\n\napp.mount(\"#app\")\n</code></pre> <p>PyScript documentation on packages</p> <p>For more information, including packages available to  MicroPython, refer to the PyScript docs.</p>"},{"location":"tutorial/09-using-web-components/","title":"Using Web Components","text":"<p>Web Components are a collection of technologies, supported by all modern browsers, that let developers reuse custom components in a framework-agnostic way. Although PuePy is an esoteric framework, and no major component libraries exist for it (as they do with React or Vue), you can use Web Component widgets easily in PuePy and make use of common components available on the Internet.</p>"},{"location":"tutorial/09-using-web-components/#using-shoelace","title":"Using Shoelace","text":"<p>Shoelace is a popular and professionally developed suite of web components for building high quality user experiences. In this example, we'll see how to use Shoelace Web Components inside a project of ours. Here is a working example:</p> <p>https://kkinder.pyscriptapps.com/puepy-tutorial/latest/tutorial/09_webcomponents/index.htmlEdit</p>"},{"location":"tutorial/09-using-web-components/#adding-remote-assets","title":"Adding remote assets","text":"<p>First, we'll need to load Shoelace from its CDN in our HTML file:</p> index.html<pre><code>&lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.1/cdn/themes/light.css\"/&gt;\n&lt;script type=\"module\"\n      src=\"https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.1/cdn/shoelace-autoloader.js\"&gt;&lt;/script&gt;\n</code></pre>"},{"location":"tutorial/09-using-web-components/#using-web-components-in-python","title":"Using Web Components in Python","text":"<p>Because WebComponents are initialized just like other HTML tags, they can be used directly in Python:</p> <p><pre><code>@app.page()\nclass DefaultPage(Page):\n    def populate(self):\n        with t.sl_dialog(label=\"Dialog\", classes=\"dialog-overview\", tag=\"sl-dialog\", ref=\"dialog\"):  # (1)!\n            t(\"Web Components are just delightful.\")\n            t.sl_button(\"Close\", slot=\"footer\", variant=\"primary\", on_click=self.on_close_click)  # (2)!\n        t.sl_button(\"Open Dialog\", tag=\"sl-button\", on_click=self.on_open_click)\n\n    def on_open_click(self, event):\n        self.refs[\"dialog\"].element.show()\n\n    def on_close_click(self, event):\n        self.refs[\"dialog\"].element.hide()\n</code></pre> 1. The <code>sl_dialog</code> tag is a custom tag that creates a <code>sl-dialog</code> Web Component. It was defined by the Shoelace library we loaded via CDN. 2. The <code>sl_button</code> tag is another custom tag that creates a <code>sl-button</code> Web Component.</p>"},{"location":"tutorial/09-using-web-components/#access-methods-and-properties-of-web-components","title":"Access methods and properties of web components","text":"<p>Web Components are meant to be access directly, like this in JavaScript:</p> <pre><code>&lt;sl-dialog id=\"foo\"&gt;&lt;/sl-dialog&gt;\n\n&lt;script&gt;\n    document.querySelector(\"#foo\").show()\n&lt;/script&gt;\n</code></pre> <p>The actual DOM elements are accessible in PuePy, but require using the <code>.element</code> attribute of the higher level Python instance of your tag:</p> <pre><code>self.refs[\"dialog\"].element.show()\n</code></pre>"},{"location":"tutorial/10-full-app/","title":"A Full App Template","text":"<p>Let's put together what we've learned so far. This example is an app with routing, a sidebar, and a handful of pages.</p> <p>https://kkinder.pyscriptapps.com/puepy-tutorial/latest/tutorial/10_full_app/index.htmlEdit</p> <p>URL Changes</p> <p>In the embedded example above, the \"URL\" does not change because the embedded example is not a full web page. In a full web page, the URL would change to reflect the current page. Try opening the example in a new window to see the URL change.</p>"},{"location":"tutorial/10-full-app/#project-layout","title":"Project layout","text":"<p>The larger example separates logic out into several files.</p> <ul> <li>main.py: The Python file started from our <code>&lt;script&gt;</code> tag</li> <li>common.py: A place to put objects common to other files</li> <li>components.py: A place to put reusable components</li> <li>pages.py: A place to put individual pages we navigate to</li> </ul>"},{"location":"tutorial/10-full-app/#configuring-pyscript-for-multiple-files","title":"Configuring PyScript for multiple files","text":"<p>To make additional source files available in the Python runtime environment, add them to the <code>files</code> list in the PyScript configuration file:</p> pyscript-app.json<pre><code>{\n  \"name\": \"PuePy Tutorial\",\n  \"debug\": true,\n  \"files\": {\n    \"./common.py\": \"common.py\",\n    \"./components.py\": \"components.py\",\n    \"./main.py\": \"main.py\",\n    \"./pages.py\": \"pages.py\"\n  },\n  \"js_modules\": {\n    \"main\": {\n      \"https://cdn.jsdelivr.net/npm/chart.js\": \"chart\",\n      \"https://cdn.jsdelivr.net/npm/morphdom@2.7.4/+esm\": \"morphdom\"\n    }\n  },\n  \"packages\": [\n    \"../../puepy-0.6.2-py3-none-any.whl\"\n  ]\n}\n</code></pre>"},{"location":"tutorial/10-full-app/#adding-chartjs","title":"Adding Chart.js","text":"<p>We also added a JavaScript library, chart.js, to the project.</p> <pre><code>  \"https://cdn.jsdelivr.net/npm/chart.js\": \"chart\"\n</code></pre> <p>JavaScript Modules</p> <p>See JavaScript Modules in PyScript's documentation for additional information on loading JavaScript libraries into your project.</p> <p>We use charts.js directly from Python, in <code>components.py</code>:</p> <pre><code>@t.component()\nclass Chart(Component):\n    props = [\"type\", \"data\", \"options\"]\n    enclosing_tag = \"canvas\"\n\n    def on_redraw(self):\n        self.call_chartjs()\n\n    def on_ready(self):\n        self.call_chartjs()\n\n    def call_chartjs(self):\n        if hasattr(self, \"_chart_js\"):\n            self._chart_js.destroy()\n\n        self._chart_js = js.Chart.new(\n            self.element,\n            jsobj(type=self.type, data=self.data, options=self.options),\n        )\n</code></pre> <p>We call the JavaScript library in two places. When the component is added to the DOM (on_ready) and when it's going to be redrawn (on_redraw).</p>"},{"location":"tutorial/10-full-app/#reusing-code","title":"Reusing Code","text":""},{"location":"tutorial/10-full-app/#a-common-app-layout","title":"A common app layout","text":"<p>In <code>components.py</code>, we define a common application layout, then reuse it in multiple pages:</p> <pre><code>class SidebarItem:\n    def __init__(self, label, icon, route):\n        self.label = label\n        self.icon = icon\n        self.route = route\n\n\n@t.component()\nclass AppLayout(Component):\n    sidebar_items = [\n        SidebarItem(\"Dashboard\", \"emoji-sunglasses\", \"dashboard_page\"),\n        SidebarItem(\"Charts\", \"graph-up\", \"charts_page\"),\n        SidebarItem(\"Forms\", \"input-cursor-text\", \"forms_page\"),\n    ]\n\n    def precheck(self):\n        if not self.application.state[\"authenticated_user\"]:\n            raise exceptions.Unauthorized()\n\n    def populate(self):\n        with t.sl_drawer(label=\"Menu\", placement=\"start\", classes=\"drawer-placement-start\", ref=\"drawer\"):\n            self.populate_sidebar()\n\n        with t.div(classes=\"container\"):\n            with t.div(classes=\"header\"):\n                with t.div():\n                    with t.sl_button(classes=\"menu-btn\", on_click=self.show_drawer):\n                        t.sl_icon(name=\"list\")\n                t.div(\"The Dapper App\")\n                self.populate_topright()\n            with t.div(classes=\"sidebar\", id=\"sidebar\"):\n                self.populate_sidebar()\n            with t.div(classes=\"main\"):\n                self.insert_slot()\n            with t.div(classes=\"footer\"):\n                t(\"Business Time!\")\n\n    def populate_topright(self):\n        with t.div(classes=\"dropdown-hoist\"):\n            with t.sl_dropdown(hoist=\"\"):\n                t.sl_icon_button(slot=\"trigger\", label=\"User Settings\", name=\"person-gear\")\n                with t.sl_menu(on_sl_select=self.on_menu_select):\n                    t.sl_menu_item(\n                        \"Profile\",\n                        t.sl_icon(slot=\"suffix\", name=\"person-badge\"),\n                        value=\"profile\",\n                    )\n                    t.sl_menu_item(\"Settings\", t.sl_icon(slot=\"suffix\", name=\"gear\"), value=\"settings\")\n                    t.sl_divider()\n                    t.sl_menu_item(\"Logout\", t.sl_icon(slot=\"suffix\", name=\"box-arrow-right\"), value=\"logout\")\n\n    def on_menu_select(self, event):\n        if event.detail.item.value == \"logout\":\n            self.application.state[\"authenticated_user\"] = \"\"\n\n    def populate_sidebar(self):\n        for item in self.sidebar_items:\n            with t.div():\n                with t.sl_button(\n                    item.label,\n                    variant=\"text\",\n                    classes=\"sidebar-button\",\n                    href=self.page.router.reverse(item.route),\n                ):\n                    if item.icon:\n                        t.sl_icon(name=item.icon, slot=\"prefix\")\n\n    def show_drawer(self, event):\n        self.refs[\"drawer\"].element.show()\n</code></pre>"},{"location":"tutorial/10-full-app/#loading-indicator","title":"Loading indicator","text":"<p>Since CPython takes a while to load on slower connections, we'll populate the <code>&lt;div id=\"app&gt;</code> element with a loading  indicator, which will be replaced once the application mounts:</p> <pre><code>&lt;div id=\"app\"&gt;\n  &lt;div style=\"text-align: center; height: 100vh; display: flex; justify-content: center; align-items: center;\"&gt;\n    &lt;sl-spinner style=\"font-size: 50px; --track-width: 10px;\"&gt;&lt;/sl-spinner&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"tutorial/10-full-app/#further-experimentation","title":"Further experimentation","text":"<p>Don't forget to try cloning and modifying all the examples from this tutorial on PyScript.com.</p>"}]}